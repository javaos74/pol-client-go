// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/tetration_network_policy.proto

/*
Package TetrationNetworkPolicyProto is a generated protocol buffer package.

It is generated from these files:
	proto/tetration_network_policy.proto

It has these top-level messages:
	AddressWithPrefix
	AddressWithRange
	LBService
	KeyValue
	InventoryItem
	InventoryFilterMetaData
	InventoryFilter
	PortRange
	ProtocolAndPorts
	FlowFilter
	IntentMetaData
	Intent
	CatchAllPolicy
	NetworkPolicy
	RootScopeInfo
	ScopeInfo
	TenantNetworkPolicy
	IntentStatus
	NetworkPolicyStatus
	TenantNetworkPolicyStatus
	KafkaUpdate
*/
package TetrationNetworkPolicyProto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type IPAddressFamily int32

const (
	IPAddressFamily_INVALID IPAddressFamily = 0
	IPAddressFamily_IPv4    IPAddressFamily = 1
	IPAddressFamily_IPv6    IPAddressFamily = 2
)

var IPAddressFamily_name = map[int32]string{
	0: "INVALID",
	1: "IPv4",
	2: "IPv6",
}
var IPAddressFamily_value = map[string]int32{
	"INVALID": 0,
	"IPv4":    1,
	"IPv6":    2,
}

func (x IPAddressFamily) String() string {
	return proto.EnumName(IPAddressFamily_name, int32(x))
}
func (IPAddressFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type IPProtocol int32

const (
	IPProtocol_IP             IPProtocol = 0
	IPProtocol_ICMP           IPProtocol = 1
	IPProtocol_IGMP           IPProtocol = 2
	IPProtocol_GGP            IPProtocol = 3
	IPProtocol_IPIP           IPProtocol = 4
	IPProtocol_ST             IPProtocol = 5
	IPProtocol_TCP            IPProtocol = 6
	IPProtocol_CBT            IPProtocol = 7
	IPProtocol_EGP            IPProtocol = 8
	IPProtocol_IGP            IPProtocol = 9
	IPProtocol_BBNRCC         IPProtocol = 10
	IPProtocol_NVP            IPProtocol = 11
	IPProtocol_PUP            IPProtocol = 12
	IPProtocol_ARGUS          IPProtocol = 13
	IPProtocol_EMCON          IPProtocol = 14
	IPProtocol_XNET           IPProtocol = 15
	IPProtocol_CHAOS          IPProtocol = 16
	IPProtocol_UDP            IPProtocol = 17
	IPProtocol_MUX            IPProtocol = 18
	IPProtocol_DCNMEAS        IPProtocol = 19
	IPProtocol_HMP            IPProtocol = 20
	IPProtocol_PRM            IPProtocol = 21
	IPProtocol_IDP            IPProtocol = 22
	IPProtocol_TRUNK1         IPProtocol = 23
	IPProtocol_TRUNK2         IPProtocol = 24
	IPProtocol_LEAF1          IPProtocol = 25
	IPProtocol_LEAF2          IPProtocol = 26
	IPProtocol_RDP            IPProtocol = 27
	IPProtocol_IRTP           IPProtocol = 28
	IPProtocol_TP             IPProtocol = 29
	IPProtocol_NETBLT         IPProtocol = 30
	IPProtocol_MFPNSP         IPProtocol = 31
	IPProtocol_MERITINP       IPProtocol = 32
	IPProtocol_SEP            IPProtocol = 33
	IPProtocol__3PC           IPProtocol = 34
	IPProtocol_IDPR           IPProtocol = 35
	IPProtocol_XTP            IPProtocol = 36
	IPProtocol_DDP            IPProtocol = 37
	IPProtocol_CMTP           IPProtocol = 38
	IPProtocol_TPPP           IPProtocol = 39
	IPProtocol_IL             IPProtocol = 40
	IPProtocol_IP6            IPProtocol = 41
	IPProtocol_SDRP           IPProtocol = 42
	IPProtocol_ROUTING        IPProtocol = 43
	IPProtocol_FRAGMENT       IPProtocol = 44
	IPProtocol_RSVP           IPProtocol = 46
	IPProtocol_GRE            IPProtocol = 47
	IPProtocol_MHRP           IPProtocol = 48
	IPProtocol_ENA            IPProtocol = 49
	IPProtocol_ESP            IPProtocol = 50
	IPProtocol_AH             IPProtocol = 51
	IPProtocol_INLSP          IPProtocol = 52
	IPProtocol_SWIPE          IPProtocol = 53
	IPProtocol_NARP           IPProtocol = 54
	IPProtocol_MOBILE         IPProtocol = 55
	IPProtocol_TLSP           IPProtocol = 56
	IPProtocol_SKIP           IPProtocol = 57
	IPProtocol_ICMP6          IPProtocol = 58
	IPProtocol_NONE           IPProtocol = 59
	IPProtocol_DSTOPTS        IPProtocol = 60
	IPProtocol_ANYHOST        IPProtocol = 61
	IPProtocol_CFTP           IPProtocol = 62
	IPProtocol_ANYNET         IPProtocol = 63
	IPProtocol_EXPAK          IPProtocol = 64
	IPProtocol_KRYPTOLAN      IPProtocol = 65
	IPProtocol_RVD            IPProtocol = 66
	IPProtocol_IPPC           IPProtocol = 67
	IPProtocol_DISTFS         IPProtocol = 68
	IPProtocol_SATMON         IPProtocol = 69
	IPProtocol_VISA           IPProtocol = 70
	IPProtocol_IPCV           IPProtocol = 71
	IPProtocol_CPNX           IPProtocol = 72
	IPProtocol_CPHB           IPProtocol = 73
	IPProtocol_WSN            IPProtocol = 74
	IPProtocol_PVP            IPProtocol = 75
	IPProtocol_BRSATMON       IPProtocol = 76
	IPProtocol_SUNND          IPProtocol = 77
	IPProtocol_WBMON          IPProtocol = 78
	IPProtocol_WBEXPAK        IPProtocol = 79
	IPProtocol_EON            IPProtocol = 80
	IPProtocol_VMTP           IPProtocol = 81
	IPProtocol_SVMTP          IPProtocol = 82
	IPProtocol_VINES          IPProtocol = 83
	IPProtocol_TTP            IPProtocol = 84
	IPProtocol_NSFIGP         IPProtocol = 85
	IPProtocol_DGP            IPProtocol = 86
	IPProtocol_TCF            IPProtocol = 87
	IPProtocol_EIGRP          IPProtocol = 88
	IPProtocol_OSPF           IPProtocol = 89
	IPProtocol_SPRITERPC      IPProtocol = 90
	IPProtocol_LARP           IPProtocol = 91
	IPProtocol_MTP            IPProtocol = 92
	IPProtocol_AX25           IPProtocol = 93
	IPProtocol_IPIPENCAP      IPProtocol = 94
	IPProtocol_MICP           IPProtocol = 95
	IPProtocol_SCCSP          IPProtocol = 96
	IPProtocol_ETHERIP        IPProtocol = 97
	IPProtocol_ENCAP          IPProtocol = 98
	IPProtocol_ANYENC         IPProtocol = 99
	IPProtocol_GMTP           IPProtocol = 100
	IPProtocol_IFMP           IPProtocol = 101
	IPProtocol_PNNI           IPProtocol = 102
	IPProtocol_PIM            IPProtocol = 103
	IPProtocol_ARIS           IPProtocol = 104
	IPProtocol_SCPS           IPProtocol = 105
	IPProtocol_QNX            IPProtocol = 106
	IPProtocol_AN             IPProtocol = 107
	IPProtocol_IPCOMP         IPProtocol = 108
	IPProtocol_SNP            IPProtocol = 109
	IPProtocol_COMPAQPEER     IPProtocol = 110
	IPProtocol_IPXIP          IPProtocol = 111
	IPProtocol_VRRP           IPProtocol = 112
	IPProtocol_PGM            IPProtocol = 113
	IPProtocol_ANY0HOP        IPProtocol = 114
	IPProtocol_L2TP           IPProtocol = 115
	IPProtocol_DDX            IPProtocol = 116
	IPProtocol_IATP           IPProtocol = 117
	IPProtocol_STP            IPProtocol = 118
	IPProtocol_SRP            IPProtocol = 119
	IPProtocol_UTI            IPProtocol = 120
	IPProtocol_SMP            IPProtocol = 121
	IPProtocol_SM             IPProtocol = 122
	IPProtocol_PTP            IPProtocol = 123
	IPProtocol_ISIS           IPProtocol = 124
	IPProtocol_FIRE           IPProtocol = 125
	IPProtocol_CRTP           IPProtocol = 126
	IPProtocol_CRUDP          IPProtocol = 127
	IPProtocol_SSCOPMCE       IPProtocol = 128
	IPProtocol_IPLT           IPProtocol = 129
	IPProtocol_SPS            IPProtocol = 130
	IPProtocol_PIPE           IPProtocol = 131
	IPProtocol_SCTP           IPProtocol = 132
	IPProtocol_FC             IPProtocol = 133
	IPProtocol_RSVPIGN        IPProtocol = 134
	IPProtocol_MOBILITYHEADER IPProtocol = 135
	IPProtocol_UDPLITE        IPProtocol = 136
	IPProtocol_MPLSINIP       IPProtocol = 137
	IPProtocol_MANET          IPProtocol = 138
	IPProtocol_HIP            IPProtocol = 139
	IPProtocol_SHIM6          IPProtocol = 140
	IPProtocol_WESP           IPProtocol = 141
	IPProtocol_ROHC           IPProtocol = 142
	IPProtocol_UNASSIGNED143  IPProtocol = 143
	IPProtocol_UNASSIGNED144  IPProtocol = 144
	IPProtocol_UNASSIGNED145  IPProtocol = 145
	IPProtocol_UNASSIGNED146  IPProtocol = 146
	IPProtocol_UNASSIGNED147  IPProtocol = 147
	IPProtocol_UNASSIGNED148  IPProtocol = 148
	IPProtocol_UNASSIGNED149  IPProtocol = 149
	IPProtocol_UNASSIGNED150  IPProtocol = 150
	IPProtocol_UNASSIGNED151  IPProtocol = 151
	IPProtocol_UNASSIGNED152  IPProtocol = 152
	IPProtocol_UNASSIGNED153  IPProtocol = 153
	IPProtocol_UNASSIGNED154  IPProtocol = 154
	IPProtocol_UNASSIGNED155  IPProtocol = 155
	IPProtocol_UNASSIGNED156  IPProtocol = 156
	IPProtocol_UNASSIGNED157  IPProtocol = 157
	IPProtocol_UNASSIGNED158  IPProtocol = 158
	IPProtocol_UNASSIGNED159  IPProtocol = 159
	IPProtocol_UNASSIGNED160  IPProtocol = 160
	IPProtocol_UNASSIGNED161  IPProtocol = 161
	IPProtocol_UNASSIGNED162  IPProtocol = 162
	IPProtocol_UNASSIGNED163  IPProtocol = 163
	IPProtocol_UNASSIGNED164  IPProtocol = 164
	IPProtocol_UNASSIGNED165  IPProtocol = 165
	IPProtocol_UNASSIGNED166  IPProtocol = 166
	IPProtocol_UNASSIGNED167  IPProtocol = 167
	IPProtocol_UNASSIGNED168  IPProtocol = 168
	IPProtocol_UNASSIGNED169  IPProtocol = 169
	IPProtocol_UNASSIGNED170  IPProtocol = 170
	IPProtocol_UNASSIGNED171  IPProtocol = 171
	IPProtocol_UNASSIGNED172  IPProtocol = 172
	IPProtocol_UNASSIGNED173  IPProtocol = 173
	IPProtocol_UNASSIGNED174  IPProtocol = 174
	IPProtocol_UNASSIGNED175  IPProtocol = 175
	IPProtocol_UNASSIGNED176  IPProtocol = 176
	IPProtocol_UNASSIGNED177  IPProtocol = 177
	IPProtocol_UNASSIGNED178  IPProtocol = 178
	IPProtocol_UNASSIGNED179  IPProtocol = 179
	IPProtocol_UNASSIGNED180  IPProtocol = 180
	IPProtocol_UNASSIGNED181  IPProtocol = 181
	IPProtocol_UNASSIGNED182  IPProtocol = 182
	IPProtocol_UNASSIGNED183  IPProtocol = 183
	IPProtocol_UNASSIGNED184  IPProtocol = 184
	IPProtocol_UNASSIGNED185  IPProtocol = 185
	IPProtocol_UNASSIGNED186  IPProtocol = 186
	IPProtocol_UNASSIGNED187  IPProtocol = 187
	IPProtocol_UNASSIGNED188  IPProtocol = 188
	IPProtocol_UNASSIGNED189  IPProtocol = 189
	IPProtocol_UNASSIGNED190  IPProtocol = 190
	IPProtocol_UNASSIGNED191  IPProtocol = 191
	IPProtocol_UNASSIGNED192  IPProtocol = 192
	IPProtocol_UNASSIGNED193  IPProtocol = 193
	IPProtocol_UNASSIGNED194  IPProtocol = 194
	IPProtocol_UNASSIGNED195  IPProtocol = 195
	IPProtocol_UNASSIGNED196  IPProtocol = 196
	IPProtocol_UNASSIGNED197  IPProtocol = 197
	IPProtocol_UNASSIGNED198  IPProtocol = 198
	IPProtocol_UNASSIGNED199  IPProtocol = 199
	IPProtocol_UNASSIGNED200  IPProtocol = 200
	IPProtocol_UNASSIGNED201  IPProtocol = 201
	IPProtocol_UNASSIGNED202  IPProtocol = 202
	IPProtocol_UNASSIGNED203  IPProtocol = 203
	IPProtocol_UNASSIGNED204  IPProtocol = 204
	IPProtocol_UNASSIGNED205  IPProtocol = 205
	IPProtocol_UNASSIGNED206  IPProtocol = 206
	IPProtocol_UNASSIGNED207  IPProtocol = 207
	IPProtocol_UNASSIGNED208  IPProtocol = 208
	IPProtocol_UNASSIGNED209  IPProtocol = 209
	IPProtocol_UNASSIGNED210  IPProtocol = 210
	IPProtocol_UNASSIGNED211  IPProtocol = 211
	IPProtocol_UNASSIGNED212  IPProtocol = 212
	IPProtocol_UNASSIGNED213  IPProtocol = 213
	IPProtocol_UNASSIGNED214  IPProtocol = 214
	IPProtocol_UNASSIGNED215  IPProtocol = 215
	IPProtocol_UNASSIGNED216  IPProtocol = 216
	IPProtocol_UNASSIGNED217  IPProtocol = 217
	IPProtocol_UNASSIGNED218  IPProtocol = 218
	IPProtocol_UNASSIGNED219  IPProtocol = 219
	IPProtocol_UNASSIGNED220  IPProtocol = 220
	IPProtocol_UNASSIGNED221  IPProtocol = 221
	IPProtocol_UNASSIGNED222  IPProtocol = 222
	IPProtocol_UNASSIGNED223  IPProtocol = 223
	IPProtocol_UNASSIGNED224  IPProtocol = 224
	IPProtocol_UNASSIGNED225  IPProtocol = 225
	IPProtocol_UNASSIGNED226  IPProtocol = 226
	IPProtocol_UNASSIGNED227  IPProtocol = 227
	IPProtocol_UNASSIGNED228  IPProtocol = 228
	IPProtocol_UNASSIGNED229  IPProtocol = 229
	IPProtocol_UNASSIGNED230  IPProtocol = 230
	IPProtocol_UNASSIGNED231  IPProtocol = 231
	IPProtocol_UNASSIGNED232  IPProtocol = 232
	IPProtocol_UNASSIGNED233  IPProtocol = 233
	IPProtocol_UNASSIGNED234  IPProtocol = 234
	IPProtocol_UNASSIGNED235  IPProtocol = 235
	IPProtocol_UNASSIGNED236  IPProtocol = 236
	IPProtocol_UNASSIGNED237  IPProtocol = 237
	IPProtocol_UNASSIGNED238  IPProtocol = 238
	IPProtocol_UNASSIGNED239  IPProtocol = 239
	IPProtocol_UNASSIGNED240  IPProtocol = 240
	IPProtocol_UNASSIGNED241  IPProtocol = 241
	IPProtocol_UNASSIGNED242  IPProtocol = 242
	IPProtocol_UNASSIGNED243  IPProtocol = 243
	IPProtocol_UNASSIGNED244  IPProtocol = 244
	IPProtocol_UNASSIGNED245  IPProtocol = 245
	IPProtocol_UNASSIGNED246  IPProtocol = 246
	IPProtocol_ARP_REVREQUEST IPProtocol = 247
	IPProtocol_ARP_REVREPLY   IPProtocol = 248
	IPProtocol_ARP_REQUEST    IPProtocol = 249
	IPProtocol_ARP_REPLY      IPProtocol = 250
	IPProtocol_UNASSIGNED251  IPProtocol = 251
	IPProtocol_UNASSIGNED252  IPProtocol = 252
	IPProtocol_EXPERIMENT1    IPProtocol = 253
	IPProtocol_EXPERIMENT2    IPProtocol = 254
	IPProtocol_RESERVED       IPProtocol = 255
)

var IPProtocol_name = map[int32]string{
	0:   "IP",
	1:   "ICMP",
	2:   "IGMP",
	3:   "GGP",
	4:   "IPIP",
	5:   "ST",
	6:   "TCP",
	7:   "CBT",
	8:   "EGP",
	9:   "IGP",
	10:  "BBNRCC",
	11:  "NVP",
	12:  "PUP",
	13:  "ARGUS",
	14:  "EMCON",
	15:  "XNET",
	16:  "CHAOS",
	17:  "UDP",
	18:  "MUX",
	19:  "DCNMEAS",
	20:  "HMP",
	21:  "PRM",
	22:  "IDP",
	23:  "TRUNK1",
	24:  "TRUNK2",
	25:  "LEAF1",
	26:  "LEAF2",
	27:  "RDP",
	28:  "IRTP",
	29:  "TP",
	30:  "NETBLT",
	31:  "MFPNSP",
	32:  "MERITINP",
	33:  "SEP",
	34:  "_3PC",
	35:  "IDPR",
	36:  "XTP",
	37:  "DDP",
	38:  "CMTP",
	39:  "TPPP",
	40:  "IL",
	41:  "IP6",
	42:  "SDRP",
	43:  "ROUTING",
	44:  "FRAGMENT",
	46:  "RSVP",
	47:  "GRE",
	48:  "MHRP",
	49:  "ENA",
	50:  "ESP",
	51:  "AH",
	52:  "INLSP",
	53:  "SWIPE",
	54:  "NARP",
	55:  "MOBILE",
	56:  "TLSP",
	57:  "SKIP",
	58:  "ICMP6",
	59:  "NONE",
	60:  "DSTOPTS",
	61:  "ANYHOST",
	62:  "CFTP",
	63:  "ANYNET",
	64:  "EXPAK",
	65:  "KRYPTOLAN",
	66:  "RVD",
	67:  "IPPC",
	68:  "DISTFS",
	69:  "SATMON",
	70:  "VISA",
	71:  "IPCV",
	72:  "CPNX",
	73:  "CPHB",
	74:  "WSN",
	75:  "PVP",
	76:  "BRSATMON",
	77:  "SUNND",
	78:  "WBMON",
	79:  "WBEXPAK",
	80:  "EON",
	81:  "VMTP",
	82:  "SVMTP",
	83:  "VINES",
	84:  "TTP",
	85:  "NSFIGP",
	86:  "DGP",
	87:  "TCF",
	88:  "EIGRP",
	89:  "OSPF",
	90:  "SPRITERPC",
	91:  "LARP",
	92:  "MTP",
	93:  "AX25",
	94:  "IPIPENCAP",
	95:  "MICP",
	96:  "SCCSP",
	97:  "ETHERIP",
	98:  "ENCAP",
	99:  "ANYENC",
	100: "GMTP",
	101: "IFMP",
	102: "PNNI",
	103: "PIM",
	104: "ARIS",
	105: "SCPS",
	106: "QNX",
	107: "AN",
	108: "IPCOMP",
	109: "SNP",
	110: "COMPAQPEER",
	111: "IPXIP",
	112: "VRRP",
	113: "PGM",
	114: "ANY0HOP",
	115: "L2TP",
	116: "DDX",
	117: "IATP",
	118: "STP",
	119: "SRP",
	120: "UTI",
	121: "SMP",
	122: "SM",
	123: "PTP",
	124: "ISIS",
	125: "FIRE",
	126: "CRTP",
	127: "CRUDP",
	128: "SSCOPMCE",
	129: "IPLT",
	130: "SPS",
	131: "PIPE",
	132: "SCTP",
	133: "FC",
	134: "RSVPIGN",
	135: "MOBILITYHEADER",
	136: "UDPLITE",
	137: "MPLSINIP",
	138: "MANET",
	139: "HIP",
	140: "SHIM6",
	141: "WESP",
	142: "ROHC",
	143: "UNASSIGNED143",
	144: "UNASSIGNED144",
	145: "UNASSIGNED145",
	146: "UNASSIGNED146",
	147: "UNASSIGNED147",
	148: "UNASSIGNED148",
	149: "UNASSIGNED149",
	150: "UNASSIGNED150",
	151: "UNASSIGNED151",
	152: "UNASSIGNED152",
	153: "UNASSIGNED153",
	154: "UNASSIGNED154",
	155: "UNASSIGNED155",
	156: "UNASSIGNED156",
	157: "UNASSIGNED157",
	158: "UNASSIGNED158",
	159: "UNASSIGNED159",
	160: "UNASSIGNED160",
	161: "UNASSIGNED161",
	162: "UNASSIGNED162",
	163: "UNASSIGNED163",
	164: "UNASSIGNED164",
	165: "UNASSIGNED165",
	166: "UNASSIGNED166",
	167: "UNASSIGNED167",
	168: "UNASSIGNED168",
	169: "UNASSIGNED169",
	170: "UNASSIGNED170",
	171: "UNASSIGNED171",
	172: "UNASSIGNED172",
	173: "UNASSIGNED173",
	174: "UNASSIGNED174",
	175: "UNASSIGNED175",
	176: "UNASSIGNED176",
	177: "UNASSIGNED177",
	178: "UNASSIGNED178",
	179: "UNASSIGNED179",
	180: "UNASSIGNED180",
	181: "UNASSIGNED181",
	182: "UNASSIGNED182",
	183: "UNASSIGNED183",
	184: "UNASSIGNED184",
	185: "UNASSIGNED185",
	186: "UNASSIGNED186",
	187: "UNASSIGNED187",
	188: "UNASSIGNED188",
	189: "UNASSIGNED189",
	190: "UNASSIGNED190",
	191: "UNASSIGNED191",
	192: "UNASSIGNED192",
	193: "UNASSIGNED193",
	194: "UNASSIGNED194",
	195: "UNASSIGNED195",
	196: "UNASSIGNED196",
	197: "UNASSIGNED197",
	198: "UNASSIGNED198",
	199: "UNASSIGNED199",
	200: "UNASSIGNED200",
	201: "UNASSIGNED201",
	202: "UNASSIGNED202",
	203: "UNASSIGNED203",
	204: "UNASSIGNED204",
	205: "UNASSIGNED205",
	206: "UNASSIGNED206",
	207: "UNASSIGNED207",
	208: "UNASSIGNED208",
	209: "UNASSIGNED209",
	210: "UNASSIGNED210",
	211: "UNASSIGNED211",
	212: "UNASSIGNED212",
	213: "UNASSIGNED213",
	214: "UNASSIGNED214",
	215: "UNASSIGNED215",
	216: "UNASSIGNED216",
	217: "UNASSIGNED217",
	218: "UNASSIGNED218",
	219: "UNASSIGNED219",
	220: "UNASSIGNED220",
	221: "UNASSIGNED221",
	222: "UNASSIGNED222",
	223: "UNASSIGNED223",
	224: "UNASSIGNED224",
	225: "UNASSIGNED225",
	226: "UNASSIGNED226",
	227: "UNASSIGNED227",
	228: "UNASSIGNED228",
	229: "UNASSIGNED229",
	230: "UNASSIGNED230",
	231: "UNASSIGNED231",
	232: "UNASSIGNED232",
	233: "UNASSIGNED233",
	234: "UNASSIGNED234",
	235: "UNASSIGNED235",
	236: "UNASSIGNED236",
	237: "UNASSIGNED237",
	238: "UNASSIGNED238",
	239: "UNASSIGNED239",
	240: "UNASSIGNED240",
	241: "UNASSIGNED241",
	242: "UNASSIGNED242",
	243: "UNASSIGNED243",
	244: "UNASSIGNED244",
	245: "UNASSIGNED245",
	246: "UNASSIGNED246",
	247: "ARP_REVREQUEST",
	248: "ARP_REVREPLY",
	249: "ARP_REQUEST",
	250: "ARP_REPLY",
	251: "UNASSIGNED251",
	252: "UNASSIGNED252",
	253: "EXPERIMENT1",
	254: "EXPERIMENT2",
	255: "RESERVED",
}
var IPProtocol_value = map[string]int32{
	"IP":             0,
	"ICMP":           1,
	"IGMP":           2,
	"GGP":            3,
	"IPIP":           4,
	"ST":             5,
	"TCP":            6,
	"CBT":            7,
	"EGP":            8,
	"IGP":            9,
	"BBNRCC":         10,
	"NVP":            11,
	"PUP":            12,
	"ARGUS":          13,
	"EMCON":          14,
	"XNET":           15,
	"CHAOS":          16,
	"UDP":            17,
	"MUX":            18,
	"DCNMEAS":        19,
	"HMP":            20,
	"PRM":            21,
	"IDP":            22,
	"TRUNK1":         23,
	"TRUNK2":         24,
	"LEAF1":          25,
	"LEAF2":          26,
	"RDP":            27,
	"IRTP":           28,
	"TP":             29,
	"NETBLT":         30,
	"MFPNSP":         31,
	"MERITINP":       32,
	"SEP":            33,
	"_3PC":           34,
	"IDPR":           35,
	"XTP":            36,
	"DDP":            37,
	"CMTP":           38,
	"TPPP":           39,
	"IL":             40,
	"IP6":            41,
	"SDRP":           42,
	"ROUTING":        43,
	"FRAGMENT":       44,
	"RSVP":           46,
	"GRE":            47,
	"MHRP":           48,
	"ENA":            49,
	"ESP":            50,
	"AH":             51,
	"INLSP":          52,
	"SWIPE":          53,
	"NARP":           54,
	"MOBILE":         55,
	"TLSP":           56,
	"SKIP":           57,
	"ICMP6":          58,
	"NONE":           59,
	"DSTOPTS":        60,
	"ANYHOST":        61,
	"CFTP":           62,
	"ANYNET":         63,
	"EXPAK":          64,
	"KRYPTOLAN":      65,
	"RVD":            66,
	"IPPC":           67,
	"DISTFS":         68,
	"SATMON":         69,
	"VISA":           70,
	"IPCV":           71,
	"CPNX":           72,
	"CPHB":           73,
	"WSN":            74,
	"PVP":            75,
	"BRSATMON":       76,
	"SUNND":          77,
	"WBMON":          78,
	"WBEXPAK":        79,
	"EON":            80,
	"VMTP":           81,
	"SVMTP":          82,
	"VINES":          83,
	"TTP":            84,
	"NSFIGP":         85,
	"DGP":            86,
	"TCF":            87,
	"EIGRP":          88,
	"OSPF":           89,
	"SPRITERPC":      90,
	"LARP":           91,
	"MTP":            92,
	"AX25":           93,
	"IPIPENCAP":      94,
	"MICP":           95,
	"SCCSP":          96,
	"ETHERIP":        97,
	"ENCAP":          98,
	"ANYENC":         99,
	"GMTP":           100,
	"IFMP":           101,
	"PNNI":           102,
	"PIM":            103,
	"ARIS":           104,
	"SCPS":           105,
	"QNX":            106,
	"AN":             107,
	"IPCOMP":         108,
	"SNP":            109,
	"COMPAQPEER":     110,
	"IPXIP":          111,
	"VRRP":           112,
	"PGM":            113,
	"ANY0HOP":        114,
	"L2TP":           115,
	"DDX":            116,
	"IATP":           117,
	"STP":            118,
	"SRP":            119,
	"UTI":            120,
	"SMP":            121,
	"SM":             122,
	"PTP":            123,
	"ISIS":           124,
	"FIRE":           125,
	"CRTP":           126,
	"CRUDP":          127,
	"SSCOPMCE":       128,
	"IPLT":           129,
	"SPS":            130,
	"PIPE":           131,
	"SCTP":           132,
	"FC":             133,
	"RSVPIGN":        134,
	"MOBILITYHEADER": 135,
	"UDPLITE":        136,
	"MPLSINIP":       137,
	"MANET":          138,
	"HIP":            139,
	"SHIM6":          140,
	"WESP":           141,
	"ROHC":           142,
	"UNASSIGNED143":  143,
	"UNASSIGNED144":  144,
	"UNASSIGNED145":  145,
	"UNASSIGNED146":  146,
	"UNASSIGNED147":  147,
	"UNASSIGNED148":  148,
	"UNASSIGNED149":  149,
	"UNASSIGNED150":  150,
	"UNASSIGNED151":  151,
	"UNASSIGNED152":  152,
	"UNASSIGNED153":  153,
	"UNASSIGNED154":  154,
	"UNASSIGNED155":  155,
	"UNASSIGNED156":  156,
	"UNASSIGNED157":  157,
	"UNASSIGNED158":  158,
	"UNASSIGNED159":  159,
	"UNASSIGNED160":  160,
	"UNASSIGNED161":  161,
	"UNASSIGNED162":  162,
	"UNASSIGNED163":  163,
	"UNASSIGNED164":  164,
	"UNASSIGNED165":  165,
	"UNASSIGNED166":  166,
	"UNASSIGNED167":  167,
	"UNASSIGNED168":  168,
	"UNASSIGNED169":  169,
	"UNASSIGNED170":  170,
	"UNASSIGNED171":  171,
	"UNASSIGNED172":  172,
	"UNASSIGNED173":  173,
	"UNASSIGNED174":  174,
	"UNASSIGNED175":  175,
	"UNASSIGNED176":  176,
	"UNASSIGNED177":  177,
	"UNASSIGNED178":  178,
	"UNASSIGNED179":  179,
	"UNASSIGNED180":  180,
	"UNASSIGNED181":  181,
	"UNASSIGNED182":  182,
	"UNASSIGNED183":  183,
	"UNASSIGNED184":  184,
	"UNASSIGNED185":  185,
	"UNASSIGNED186":  186,
	"UNASSIGNED187":  187,
	"UNASSIGNED188":  188,
	"UNASSIGNED189":  189,
	"UNASSIGNED190":  190,
	"UNASSIGNED191":  191,
	"UNASSIGNED192":  192,
	"UNASSIGNED193":  193,
	"UNASSIGNED194":  194,
	"UNASSIGNED195":  195,
	"UNASSIGNED196":  196,
	"UNASSIGNED197":  197,
	"UNASSIGNED198":  198,
	"UNASSIGNED199":  199,
	"UNASSIGNED200":  200,
	"UNASSIGNED201":  201,
	"UNASSIGNED202":  202,
	"UNASSIGNED203":  203,
	"UNASSIGNED204":  204,
	"UNASSIGNED205":  205,
	"UNASSIGNED206":  206,
	"UNASSIGNED207":  207,
	"UNASSIGNED208":  208,
	"UNASSIGNED209":  209,
	"UNASSIGNED210":  210,
	"UNASSIGNED211":  211,
	"UNASSIGNED212":  212,
	"UNASSIGNED213":  213,
	"UNASSIGNED214":  214,
	"UNASSIGNED215":  215,
	"UNASSIGNED216":  216,
	"UNASSIGNED217":  217,
	"UNASSIGNED218":  218,
	"UNASSIGNED219":  219,
	"UNASSIGNED220":  220,
	"UNASSIGNED221":  221,
	"UNASSIGNED222":  222,
	"UNASSIGNED223":  223,
	"UNASSIGNED224":  224,
	"UNASSIGNED225":  225,
	"UNASSIGNED226":  226,
	"UNASSIGNED227":  227,
	"UNASSIGNED228":  228,
	"UNASSIGNED229":  229,
	"UNASSIGNED230":  230,
	"UNASSIGNED231":  231,
	"UNASSIGNED232":  232,
	"UNASSIGNED233":  233,
	"UNASSIGNED234":  234,
	"UNASSIGNED235":  235,
	"UNASSIGNED236":  236,
	"UNASSIGNED237":  237,
	"UNASSIGNED238":  238,
	"UNASSIGNED239":  239,
	"UNASSIGNED240":  240,
	"UNASSIGNED241":  241,
	"UNASSIGNED242":  242,
	"UNASSIGNED243":  243,
	"UNASSIGNED244":  244,
	"UNASSIGNED245":  245,
	"UNASSIGNED246":  246,
	"ARP_REVREQUEST": 247,
	"ARP_REVREPLY":   248,
	"ARP_REQUEST":    249,
	"ARP_REPLY":      250,
	"UNASSIGNED251":  251,
	"UNASSIGNED252":  252,
	"EXPERIMENT1":    253,
	"EXPERIMENT2":    254,
	"RESERVED":       255,
}

func (x IPProtocol) String() string {
	return proto.EnumName(IPProtocol_name, int32(x))
}
func (IPProtocol) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Intent_Action int32

const (
	Intent_INVALID Intent_Action = 0
	// Allow the corresponding flows.
	Intent_ALLOW Intent_Action = 1
	// DROP the corresponding flows.
	Intent_DROP Intent_Action = 2
)

var Intent_Action_name = map[int32]string{
	0: "INVALID",
	1: "ALLOW",
	2: "DROP",
}
var Intent_Action_value = map[string]int32{
	"INVALID": 0,
	"ALLOW":   1,
	"DROP":    2,
}

func (x Intent_Action) String() string {
	return proto.EnumName(Intent_Action_name, int32(x))
}
func (Intent_Action) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 0} }

// Identifies the enforcement point of the intent.
type Intent_TargetDevice int32

const (
	// Inside VM, Bare-metal or containers.
	Intent_WORKLOAD Intent_TargetDevice = 0
	// In network using SDN tools like ACI.
	Intent_NETWORK_FABRIC Intent_TargetDevice = 1
	// Load balancers and NAT devices that support enforcement.
	Intent_MIDDLE_BOXES Intent_TargetDevice = 2
	// Firewalls
	Intent_FIREWALLS Intent_TargetDevice = 3
)

var Intent_TargetDevice_name = map[int32]string{
	0: "WORKLOAD",
	1: "NETWORK_FABRIC",
	2: "MIDDLE_BOXES",
	3: "FIREWALLS",
}
var Intent_TargetDevice_value = map[string]int32{
	"WORKLOAD":       0,
	"NETWORK_FABRIC": 1,
	"MIDDLE_BOXES":   2,
	"FIREWALLS":      3,
}

func (x Intent_TargetDevice) String() string {
	return proto.EnumName(Intent_TargetDevice_name, int32(x))
}
func (Intent_TargetDevice) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 1} }

type CatchAllPolicy_Action int32

const (
	CatchAllPolicy_INVALID CatchAllPolicy_Action = 0
	// Allow the corresponding flows.
	CatchAllPolicy_ALLOW CatchAllPolicy_Action = 1
	// DROP the corresponding flows.
	CatchAllPolicy_DROP CatchAllPolicy_Action = 2
)

var CatchAllPolicy_Action_name = map[int32]string{
	0: "INVALID",
	1: "ALLOW",
	2: "DROP",
}
var CatchAllPolicy_Action_value = map[string]int32{
	"INVALID": 0,
	"ALLOW":   1,
	"DROP":    2,
}

func (x CatchAllPolicy_Action) String() string {
	return proto.EnumName(CatchAllPolicy_Action_name, int32(x))
}
func (CatchAllPolicy_Action) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0} }

// Status of enforcement reported by the client.
type IntentStatus_Status int32

const (
	IntentStatus_UNKNOWN IntentStatus_Status = 0
	// Client cannot enforce this policy.
	IntentStatus_IGNORED IntentStatus_Status = 1
	// Client can enforce this policy. However, encountered an error while
	// trying to enforce the policy.
	IntentStatus_FAILED IntentStatus_Status = 2
	// Successfully enforced.
	IntentStatus_ENFORCED IntentStatus_Status = 3
	// Client enforced a relaxed policy. Indicates that more flows will be
	// allowed than what the intent prescribed. Clients cannot modify the
	// policy to drop flows that intent says allow.
	IntentStatus_MODIFIED_AND_ENFORCED IntentStatus_Status = 4
)

var IntentStatus_Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "IGNORED",
	2: "FAILED",
	3: "ENFORCED",
	4: "MODIFIED_AND_ENFORCED",
}
var IntentStatus_Status_value = map[string]int32{
	"UNKNOWN":               0,
	"IGNORED":               1,
	"FAILED":                2,
	"ENFORCED":              3,
	"MODIFIED_AND_ENFORCED": 4,
}

func (x IntentStatus_Status) String() string {
	return proto.EnumName(IntentStatus_Status_name, int32(x))
}
func (IntentStatus_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{17, 0} }

type KafkaUpdate_UpdateType int32

const (
	// Start marker for a new policy update.
	KafkaUpdate_UPDATE_START KafkaUpdate_UpdateType = 0
	// Message part of the policy update.
	KafkaUpdate_UPDATE KafkaUpdate_UpdateType = 1
	// End marker for the current policy update.
	KafkaUpdate_UPDATE_END KafkaUpdate_UpdateType = 2
)

var KafkaUpdate_UpdateType_name = map[int32]string{
	0: "UPDATE_START",
	1: "UPDATE",
	2: "UPDATE_END",
}
var KafkaUpdate_UpdateType_value = map[string]int32{
	"UPDATE_START": 0,
	"UPDATE":       1,
	"UPDATE_END":   2,
}

func (x KafkaUpdate_UpdateType) String() string {
	return proto.EnumName(KafkaUpdate_UpdateType_name, int32(x))
}
func (KafkaUpdate_UpdateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{20, 0} }

// IP address with prefix.
type AddressWithPrefix struct {
	// IP Address in Network Byte Order.
	IpAddr       []byte `protobuf:"bytes,1,opt,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	PrefixLength uint32 `protobuf:"varint,2,opt,name=prefix_length,json=prefixLength" json:"prefix_length,omitempty"`
	// Address family
	AddrFamily IPAddressFamily `protobuf:"varint,3,opt,name=addr_family,json=addrFamily,enum=TetrationNetworkPolicyProto.IPAddressFamily" json:"addr_family,omitempty"`
}

func (m *AddressWithPrefix) Reset()                    { *m = AddressWithPrefix{} }
func (m *AddressWithPrefix) String() string            { return proto.CompactTextString(m) }
func (*AddressWithPrefix) ProtoMessage()               {}
func (*AddressWithPrefix) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AddressWithPrefix) GetIpAddr() []byte {
	if m != nil {
		return m.IpAddr
	}
	return nil
}

func (m *AddressWithPrefix) GetPrefixLength() uint32 {
	if m != nil {
		return m.PrefixLength
	}
	return 0
}

func (m *AddressWithPrefix) GetAddrFamily() IPAddressFamily {
	if m != nil {
		return m.AddrFamily
	}
	return IPAddressFamily_INVALID
}

// Message to represent a contiguous range of IP Addresses.
type AddressWithRange struct {
	// Start IP Address in Network Byte Order.
	StartIpAddr []byte `protobuf:"bytes,1,opt,name=start_ip_addr,json=startIpAddr,proto3" json:"start_ip_addr,omitempty"`
	// End IP Address in Network Byte Order. End IP Address must be greater than
	// start IP Address.
	EndIpAddr []byte `protobuf:"bytes,2,opt,name=end_ip_addr,json=endIpAddr,proto3" json:"end_ip_addr,omitempty"`
	// Address family
	AddrFamily IPAddressFamily `protobuf:"varint,3,opt,name=addr_family,json=addrFamily,enum=TetrationNetworkPolicyProto.IPAddressFamily" json:"addr_family,omitempty"`
}

func (m *AddressWithRange) Reset()                    { *m = AddressWithRange{} }
func (m *AddressWithRange) String() string            { return proto.CompactTextString(m) }
func (*AddressWithRange) ProtoMessage()               {}
func (*AddressWithRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AddressWithRange) GetStartIpAddr() []byte {
	if m != nil {
		return m.StartIpAddr
	}
	return nil
}

func (m *AddressWithRange) GetEndIpAddr() []byte {
	if m != nil {
		return m.EndIpAddr
	}
	return nil
}

func (m *AddressWithRange) GetAddrFamily() IPAddressFamily {
	if m != nil {
		return m.AddrFamily
	}
	return IPAddressFamily_INVALID
}

// When we enforce on Load Balancer devices we will expose VIPs, URLs and
// service names as members of InventoryFilter. Note that an InventoryFilter
// with members of LBService can be used only as provider_filter_id in
// FlowFilter.
type LBService struct {
	// Types that are valid to be assigned to ServiceName:
	//	*LBService_Vip
	//	*LBService_Url
	//	*LBService_Name
	ServiceName isLBService_ServiceName `protobuf_oneof:"ServiceName"`
}

func (m *LBService) Reset()                    { *m = LBService{} }
func (m *LBService) String() string            { return proto.CompactTextString(m) }
func (*LBService) ProtoMessage()               {}
func (*LBService) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isLBService_ServiceName interface {
	isLBService_ServiceName()
}

type LBService_Vip struct {
	Vip *AddressWithPrefix `protobuf:"bytes,1,opt,name=vip,oneof"`
}
type LBService_Url struct {
	Url string `protobuf:"bytes,2,opt,name=url,oneof"`
}
type LBService_Name struct {
	Name string `protobuf:"bytes,3,opt,name=name,oneof"`
}

func (*LBService_Vip) isLBService_ServiceName()  {}
func (*LBService_Url) isLBService_ServiceName()  {}
func (*LBService_Name) isLBService_ServiceName() {}

func (m *LBService) GetServiceName() isLBService_ServiceName {
	if m != nil {
		return m.ServiceName
	}
	return nil
}

func (m *LBService) GetVip() *AddressWithPrefix {
	if x, ok := m.GetServiceName().(*LBService_Vip); ok {
		return x.Vip
	}
	return nil
}

func (m *LBService) GetUrl() string {
	if x, ok := m.GetServiceName().(*LBService_Url); ok {
		return x.Url
	}
	return ""
}

func (m *LBService) GetName() string {
	if x, ok := m.GetServiceName().(*LBService_Name); ok {
		return x.Name
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LBService) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LBService_OneofMarshaler, _LBService_OneofUnmarshaler, _LBService_OneofSizer, []interface{}{
		(*LBService_Vip)(nil),
		(*LBService_Url)(nil),
		(*LBService_Name)(nil),
	}
}

func _LBService_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LBService)
	// ServiceName
	switch x := m.ServiceName.(type) {
	case *LBService_Vip:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vip); err != nil {
			return err
		}
	case *LBService_Url:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Url)
	case *LBService_Name:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Name)
	case nil:
	default:
		return fmt.Errorf("LBService.ServiceName has unexpected type %T", x)
	}
	return nil
}

func _LBService_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LBService)
	switch tag {
	case 1: // ServiceName.vip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressWithPrefix)
		err := b.DecodeMessage(msg)
		m.ServiceName = &LBService_Vip{msg}
		return true, err
	case 2: // ServiceName.url
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ServiceName = &LBService_Url{x}
		return true, err
	case 3: // ServiceName.name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ServiceName = &LBService_Name{x}
		return true, err
	default:
		return false, nil
	}
}

func _LBService_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LBService)
	// ServiceName
	switch x := m.ServiceName.(type) {
	case *LBService_Vip:
		s := proto.Size(x.Vip)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LBService_Url:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Url)))
		n += len(x.Url)
	case *LBService_Name:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Name)))
		n += len(x.Name)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type KeyValue struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *KeyValue) Reset()                    { *m = KeyValue{} }
func (m *KeyValue) String() string            { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()               {}
func (*KeyValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *KeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// An inventory item specifies cluster entities such as servers, appliances.
// It can be either a singular IP address, a subnet or an address range.
type InventoryItem struct {
	// Types that are valid to be assigned to Address:
	//	*InventoryItem_IpAddress
	//	*InventoryItem_AddressRange
	//	*InventoryItem_LbService
	Address isInventoryItem_Address `protobuf_oneof:"address"`
}

func (m *InventoryItem) Reset()                    { *m = InventoryItem{} }
func (m *InventoryItem) String() string            { return proto.CompactTextString(m) }
func (*InventoryItem) ProtoMessage()               {}
func (*InventoryItem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isInventoryItem_Address interface {
	isInventoryItem_Address()
}

type InventoryItem_IpAddress struct {
	IpAddress *AddressWithPrefix `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress,oneof"`
}
type InventoryItem_AddressRange struct {
	AddressRange *AddressWithRange `protobuf:"bytes,2,opt,name=address_range,json=addressRange,oneof"`
}
type InventoryItem_LbService struct {
	LbService *LBService `protobuf:"bytes,4,opt,name=lb_service,json=lbService,oneof"`
}

func (*InventoryItem_IpAddress) isInventoryItem_Address()    {}
func (*InventoryItem_AddressRange) isInventoryItem_Address() {}
func (*InventoryItem_LbService) isInventoryItem_Address()    {}

func (m *InventoryItem) GetAddress() isInventoryItem_Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *InventoryItem) GetIpAddress() *AddressWithPrefix {
	if x, ok := m.GetAddress().(*InventoryItem_IpAddress); ok {
		return x.IpAddress
	}
	return nil
}

func (m *InventoryItem) GetAddressRange() *AddressWithRange {
	if x, ok := m.GetAddress().(*InventoryItem_AddressRange); ok {
		return x.AddressRange
	}
	return nil
}

func (m *InventoryItem) GetLbService() *LBService {
	if x, ok := m.GetAddress().(*InventoryItem_LbService); ok {
		return x.LbService
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InventoryItem) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InventoryItem_OneofMarshaler, _InventoryItem_OneofUnmarshaler, _InventoryItem_OneofSizer, []interface{}{
		(*InventoryItem_IpAddress)(nil),
		(*InventoryItem_AddressRange)(nil),
		(*InventoryItem_LbService)(nil),
	}
}

func _InventoryItem_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InventoryItem)
	// address
	switch x := m.Address.(type) {
	case *InventoryItem_IpAddress:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IpAddress); err != nil {
			return err
		}
	case *InventoryItem_AddressRange:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AddressRange); err != nil {
			return err
		}
	case *InventoryItem_LbService:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LbService); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InventoryItem.Address has unexpected type %T", x)
	}
	return nil
}

func _InventoryItem_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InventoryItem)
	switch tag {
	case 1: // address.ip_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressWithPrefix)
		err := b.DecodeMessage(msg)
		m.Address = &InventoryItem_IpAddress{msg}
		return true, err
	case 2: // address.address_range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AddressWithRange)
		err := b.DecodeMessage(msg)
		m.Address = &InventoryItem_AddressRange{msg}
		return true, err
	case 4: // address.lb_service
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LBService)
		err := b.DecodeMessage(msg)
		m.Address = &InventoryItem_LbService{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InventoryItem_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InventoryItem)
	// address
	switch x := m.Address.(type) {
	case *InventoryItem_IpAddress:
		s := proto.Size(x.IpAddress)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InventoryItem_AddressRange:
		s := proto.Size(x.AddressRange)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InventoryItem_LbService:
		s := proto.Size(x.LbService)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Tetration debug information related to InventoryFilters.
type InventoryFilterMetaData struct {
	// ID of the scope where corresponding inventory filter is defined.
	ScopeId string `protobuf:"bytes,1,opt,name=scope_id,json=scopeId" json:"scope_id,omitempty"`
	// Human readable name assigned to the scope.
	ScopeName string `protobuf:"bytes,2,opt,name=scope_name,json=scopeName" json:"scope_name,omitempty"`
}

func (m *InventoryFilterMetaData) Reset()                    { *m = InventoryFilterMetaData{} }
func (m *InventoryFilterMetaData) String() string            { return proto.CompactTextString(m) }
func (*InventoryFilterMetaData) ProtoMessage()               {}
func (*InventoryFilterMetaData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *InventoryFilterMetaData) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

func (m *InventoryFilterMetaData) GetScopeName() string {
	if m != nil {
		return m.ScopeName
	}
	return ""
}

// Inventory filter represents a grouping of inventory items. They will be
// referenced by Flow Filters.
type InventoryFilter struct {
	// Unique identifier assigned to inventory filter. Flow filters will refer
	// to these values. If a given update has multiple InventoryFilter messages
	// with the same id then the clients will merge inventory_items to construct
	// the complete inventory filter.
	Id             string           `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	InventoryItems []*InventoryItem `protobuf:"bytes,2,rep,name=inventory_items,json=inventoryItems" json:"inventory_items,omitempty"`
	// Query filter json representation. It enables us to identify the common
	// attributes of inventory_items that group them together.
	Query string `protobuf:"bytes,3,opt,name=query" json:"query,omitempty"`
	// Human readable name assigned to this inventory filter.
	Name string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	// Any tags defined in Tetration for a specific inventory filter will be
	// provided here.
	// Note these tags are opaque for Tetration. Clients can add these Tags
	// through rest interface. Tetration passes them as-is on Kafka.
	Tags []*KeyValue `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
	// Debug information.
	MetaData *InventoryFilterMetaData `protobuf:"bytes,6,opt,name=meta_data,json=metaData" json:"meta_data,omitempty"`
}

func (m *InventoryFilter) Reset()                    { *m = InventoryFilter{} }
func (m *InventoryFilter) String() string            { return proto.CompactTextString(m) }
func (*InventoryFilter) ProtoMessage()               {}
func (*InventoryFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *InventoryFilter) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InventoryFilter) GetInventoryItems() []*InventoryItem {
	if m != nil {
		return m.InventoryItems
	}
	return nil
}

func (m *InventoryFilter) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *InventoryFilter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *InventoryFilter) GetTags() []*KeyValue {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *InventoryFilter) GetMetaData() *InventoryFilterMetaData {
	if m != nil {
		return m.MetaData
	}
	return nil
}

// Used to represent contiguous port numbers.
type PortRange struct {
	StartPort uint32 `protobuf:"varint,1,opt,name=start_port,json=startPort" json:"start_port,omitempty"`
	EndPort   uint32 `protobuf:"varint,2,opt,name=end_port,json=endPort" json:"end_port,omitempty"`
}

func (m *PortRange) Reset()                    { *m = PortRange{} }
func (m *PortRange) String() string            { return proto.CompactTextString(m) }
func (*PortRange) ProtoMessage()               {}
func (*PortRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PortRange) GetStartPort() uint32 {
	if m != nil {
		return m.StartPort
	}
	return 0
}

func (m *PortRange) GetEndPort() uint32 {
	if m != nil {
		return m.EndPort
	}
	return 0
}

type ProtocolAndPorts struct {
	Protocol   IPProtocol   `protobuf:"varint,1,opt,name=protocol,enum=TetrationNetworkPolicyProto.IPProtocol" json:"protocol,omitempty"`
	PortRanges []*PortRange `protobuf:"bytes,2,rep,name=port_ranges,json=portRanges" json:"port_ranges,omitempty"`
	Ports      []uint32     `protobuf:"varint,3,rep,packed,name=ports" json:"ports,omitempty"`
}

func (m *ProtocolAndPorts) Reset()                    { *m = ProtocolAndPorts{} }
func (m *ProtocolAndPorts) String() string            { return proto.CompactTextString(m) }
func (*ProtocolAndPorts) ProtoMessage()               {}
func (*ProtocolAndPorts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ProtocolAndPorts) GetProtocol() IPProtocol {
	if m != nil {
		return m.Protocol
	}
	return IPProtocol_IP
}

func (m *ProtocolAndPorts) GetPortRanges() []*PortRange {
	if m != nil {
		return m.PortRanges
	}
	return nil
}

func (m *ProtocolAndPorts) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

// Defines the match criteria for Intents.
type FlowFilter struct {
	// Unique id assigned to this FlowFilter.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Id of inventory filter corresponding to consumers of a service.
	ConsumerFilterId string `protobuf:"bytes,2,opt,name=consumer_filter_id,json=consumerFilterId" json:"consumer_filter_id,omitempty"`
	// Id of inventory filter corresponding to providers of a service.
	ProviderFilterId string `protobuf:"bytes,3,opt,name=provider_filter_id,json=providerFilterId" json:"provider_filter_id,omitempty"`
	// List of ports and protocols where the service is accessible.
	ProtocolAndPorts []*ProtocolAndPorts `protobuf:"bytes,4,rep,name=protocol_and_ports,json=protocolAndPorts" json:"protocol_and_ports,omitempty"`
}

func (m *FlowFilter) Reset()                    { *m = FlowFilter{} }
func (m *FlowFilter) String() string            { return proto.CompactTextString(m) }
func (*FlowFilter) ProtoMessage()               {}
func (*FlowFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *FlowFilter) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FlowFilter) GetConsumerFilterId() string {
	if m != nil {
		return m.ConsumerFilterId
	}
	return ""
}

func (m *FlowFilter) GetProviderFilterId() string {
	if m != nil {
		return m.ProviderFilterId
	}
	return ""
}

func (m *FlowFilter) GetProtocolAndPorts() []*ProtocolAndPorts {
	if m != nil {
		return m.ProtocolAndPorts
	}
	return nil
}

// Contains debug information from Tetration.
type IntentMetaData struct {
	// The intent due to which this policy exists.
	IntentId string `protobuf:"bytes,1,opt,name=intent_id,json=intentId" json:"intent_id,omitempty"`
	HashId   string `protobuf:"bytes,2,opt,name=hash_id,json=hashId" json:"hash_id,omitempty"`
	// The workspace due to which this policy exists.
	WorkspaceId string `protobuf:"bytes,3,opt,name=workspace_id,json=workspaceId" json:"workspace_id,omitempty"`
	// Fields to help trace the ADM related constructs that is responsible for
	// creating this intent.
	AdmDataSetId        string `protobuf:"bytes,4,opt,name=adm_data_set_id,json=admDataSetId" json:"adm_data_set_id,omitempty"`
	AdmDataSetVersion   string `protobuf:"bytes,5,opt,name=adm_data_set_version,json=admDataSetVersion" json:"adm_data_set_version,omitempty"`
	PolicyIntentGroupId string `protobuf:"bytes,6,opt,name=policy_intent_group_id,json=policyIntentGroupId" json:"policy_intent_group_id,omitempty"`
	ClusterEdgeId       string `protobuf:"bytes,7,opt,name=cluster_edge_id,json=clusterEdgeId" json:"cluster_edge_id,omitempty"`
	// Unique identifier of the scope corresponding to workspace_id.
	ScopeId string `protobuf:"bytes,8,opt,name=scope_id,json=scopeId" json:"scope_id,omitempty"`
	// Human readable scope name.
	ScopeName string `protobuf:"bytes,9,opt,name=scope_name,json=scopeName" json:"scope_name,omitempty"`
}

func (m *IntentMetaData) Reset()                    { *m = IntentMetaData{} }
func (m *IntentMetaData) String() string            { return proto.CompactTextString(m) }
func (*IntentMetaData) ProtoMessage()               {}
func (*IntentMetaData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *IntentMetaData) GetIntentId() string {
	if m != nil {
		return m.IntentId
	}
	return ""
}

func (m *IntentMetaData) GetHashId() string {
	if m != nil {
		return m.HashId
	}
	return ""
}

func (m *IntentMetaData) GetWorkspaceId() string {
	if m != nil {
		return m.WorkspaceId
	}
	return ""
}

func (m *IntentMetaData) GetAdmDataSetId() string {
	if m != nil {
		return m.AdmDataSetId
	}
	return ""
}

func (m *IntentMetaData) GetAdmDataSetVersion() string {
	if m != nil {
		return m.AdmDataSetVersion
	}
	return ""
}

func (m *IntentMetaData) GetPolicyIntentGroupId() string {
	if m != nil {
		return m.PolicyIntentGroupId
	}
	return ""
}

func (m *IntentMetaData) GetClusterEdgeId() string {
	if m != nil {
		return m.ClusterEdgeId
	}
	return ""
}

func (m *IntentMetaData) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

func (m *IntentMetaData) GetScopeName() string {
	if m != nil {
		return m.ScopeName
	}
	return ""
}

type Intent struct {
	// Unique id assigned to this Intent.
	Id         string      `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	FlowFilter *FlowFilter `protobuf:"bytes,2,opt,name=flow_filter,json=flowFilter" json:"flow_filter,omitempty"`
	// Action to be taken for corresponding flows.
	Action Intent_Action `protobuf:"varint,3,opt,name=action,enum=TetrationNetworkPolicyProto.Intent_Action" json:"action,omitempty"`
	// List of target devices where we want the intent to be enforced.
	TargetDevices []Intent_TargetDevice `protobuf:"varint,4,rep,packed,name=target_devices,json=targetDevices,enum=TetrationNetworkPolicyProto.Intent_TargetDevice" json:"target_devices,omitempty"`
	// Any tags defined in Tetration for a specific intent will be provided here.
	// Note these tags are opaque for Tetration. Clients can add these Tags
	// through rest interface. Tetration passes them as-is on Kafka.
	Tags []*KeyValue `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
	// Tetration debug information. Can be used to link back to Applications and
	// workspaces using either UI or OPenAPI
	MetaData *IntentMetaData `protobuf:"bytes,6,opt,name=meta_data,json=metaData" json:"meta_data,omitempty"`
	// Human readable Intent name.
	IntentName string `protobuf:"bytes,7,opt,name=intent_name,json=intentName" json:"intent_name,omitempty"`
}

func (m *Intent) Reset()                    { *m = Intent{} }
func (m *Intent) String() string            { return proto.CompactTextString(m) }
func (*Intent) ProtoMessage()               {}
func (*Intent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Intent) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Intent) GetFlowFilter() *FlowFilter {
	if m != nil {
		return m.FlowFilter
	}
	return nil
}

func (m *Intent) GetAction() Intent_Action {
	if m != nil {
		return m.Action
	}
	return Intent_INVALID
}

func (m *Intent) GetTargetDevices() []Intent_TargetDevice {
	if m != nil {
		return m.TargetDevices
	}
	return nil
}

func (m *Intent) GetTags() []*KeyValue {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Intent) GetMetaData() *IntentMetaData {
	if m != nil {
		return m.MetaData
	}
	return nil
}

func (m *Intent) GetIntentName() string {
	if m != nil {
		return m.IntentName
	}
	return ""
}

// CatchAll policy action.
type CatchAllPolicy struct {
	Action CatchAllPolicy_Action `protobuf:"varint,1,opt,name=action,enum=TetrationNetworkPolicyProto.CatchAllPolicy_Action" json:"action,omitempty"`
}

func (m *CatchAllPolicy) Reset()                    { *m = CatchAllPolicy{} }
func (m *CatchAllPolicy) String() string            { return proto.CompactTextString(m) }
func (*CatchAllPolicy) ProtoMessage()               {}
func (*CatchAllPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *CatchAllPolicy) GetAction() CatchAllPolicy_Action {
	if m != nil {
		return m.Action
	}
	return CatchAllPolicy_INVALID
}

type NetworkPolicy struct {
	// Fully expanded inventory filters.
	InventoryFilters []*InventoryFilter `protobuf:"bytes,1,rep,name=inventory_filters,json=inventoryFilters" json:"inventory_filters,omitempty"`
	// Order of intents in decreasing order of priority.
	Intents []*Intent `protobuf:"bytes,2,rep,name=intents" json:"intents,omitempty"`
	// Catch All policy.
	CatchAll *CatchAllPolicy `protobuf:"bytes,3,opt,name=catch_all,json=catchAll" json:"catch_all,omitempty"`
}

func (m *NetworkPolicy) Reset()                    { *m = NetworkPolicy{} }
func (m *NetworkPolicy) String() string            { return proto.CompactTextString(m) }
func (*NetworkPolicy) ProtoMessage()               {}
func (*NetworkPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *NetworkPolicy) GetInventoryFilters() []*InventoryFilter {
	if m != nil {
		return m.InventoryFilters
	}
	return nil
}

func (m *NetworkPolicy) GetIntents() []*Intent {
	if m != nil {
		return m.Intents
	}
	return nil
}

func (m *NetworkPolicy) GetCatchAll() *CatchAllPolicy {
	if m != nil {
		return m.CatchAll
	}
	return nil
}

// Each Tenant in Tetration is represented by root scope. All root scope
// information is captured in this message.
type RootScopeInfo struct {
	// Unique id of the root scope.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Human readable name.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
}

func (m *RootScopeInfo) Reset()                    { *m = RootScopeInfo{} }
func (m *RootScopeInfo) String() string            { return proto.CompactTextString(m) }
func (*RootScopeInfo) ProtoMessage()               {}
func (*RootScopeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *RootScopeInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RootScopeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ScopeInfo struct {
	// Unique id of the scope.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Human readable name assigned to the scope.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Unique id of the parent scope.
	ParentId string `protobuf:"bytes,3,opt,name=parent_id,json=parentId" json:"parent_id,omitempty"`
	// Tags assigned to the scopes by clients. All the inventory filters defined
	// in this scope will get these tags and the tags from the parent scopes.
	Tags []*KeyValue `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
}

func (m *ScopeInfo) Reset()                    { *m = ScopeInfo{} }
func (m *ScopeInfo) String() string            { return proto.CompactTextString(m) }
func (*ScopeInfo) ProtoMessage()               {}
func (*ScopeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ScopeInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ScopeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ScopeInfo) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *ScopeInfo) GetTags() []*KeyValue {
	if m != nil {
		return m.Tags
	}
	return nil
}

type TenantNetworkPolicy struct {
	// Unique name assigned to tenant. It's the same as the root-scope name.
	TenantName string `protobuf:"bytes,1,opt,name=tenant_name,json=tenantName" json:"tenant_name,omitempty"`
	// Network policy corresponding to tenant_name. Note that policy for one
	// tenant might be split across several TenantNetworkPolicy messages. To
	// reconstruct the policy state we need to append NetworkPolicy from multiple
	// messages in the same order of TenantNetworkPolicy.
	NetworkPolicy []*NetworkPolicy `protobuf:"bytes,2,rep,name=network_policy,json=networkPolicy" json:"network_policy,omitempty"`
	// Repeated list of network VRFs that are part of the Tenant. Please note
	// that multiple  network_vrfs are part of single Tetration VRF.
	NetworkVrfs   []string       `protobuf:"bytes,3,rep,name=network_vrfs,json=networkVrfs" json:"network_vrfs,omitempty"`
	RootScopeInfo *RootScopeInfo `protobuf:"bytes,4,opt,name=root_scope_info,json=rootScopeInfo" json:"root_scope_info,omitempty"`
	// Map of all the sub-scopes in root-scopes. The key of this map is the
	// scope id.
	Scopes map[string]*ScopeInfo `protobuf:"bytes,5,rep,name=scopes" json:"scopes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *TenantNetworkPolicy) Reset()                    { *m = TenantNetworkPolicy{} }
func (m *TenantNetworkPolicy) String() string            { return proto.CompactTextString(m) }
func (*TenantNetworkPolicy) ProtoMessage()               {}
func (*TenantNetworkPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *TenantNetworkPolicy) GetTenantName() string {
	if m != nil {
		return m.TenantName
	}
	return ""
}

func (m *TenantNetworkPolicy) GetNetworkPolicy() []*NetworkPolicy {
	if m != nil {
		return m.NetworkPolicy
	}
	return nil
}

func (m *TenantNetworkPolicy) GetNetworkVrfs() []string {
	if m != nil {
		return m.NetworkVrfs
	}
	return nil
}

func (m *TenantNetworkPolicy) GetRootScopeInfo() *RootScopeInfo {
	if m != nil {
		return m.RootScopeInfo
	}
	return nil
}

func (m *TenantNetworkPolicy) GetScopes() map[string]*ScopeInfo {
	if m != nil {
		return m.Scopes
	}
	return nil
}

type IntentStatus struct {
	// unique id assigned to the intent in NetworkPolicy.
	IntentId string              `protobuf:"bytes,1,opt,name=intent_id,json=intentId" json:"intent_id,omitempty"`
	Status   IntentStatus_Status `protobuf:"varint,2,opt,name=status,enum=TetrationNetworkPolicyProto.IntentStatus_Status" json:"status,omitempty"`
	// Time when the status of the intent has changed. Time is measured as number
	// of microseconds that have elapsed since unix epoch started.
	TimestampUsec uint64 `protobuf:"varint,3,opt,name=timestamp_usec,json=timestampUsec" json:"timestamp_usec,omitempty"`
	// This message is set only when the status is MODIFIED_AND_ENFORCED. This
	// will let the clients inform Tetration on how the intent was modified.
	ModifiedFlowFilter *FlowFilter `protobuf:"bytes,4,opt,name=modified_flow_filter,json=modifiedFlowFilter" json:"modified_flow_filter,omitempty"`
	// If status is set to IGNORED or FAILED then client will include any debug
	// info in status_reason.
	StatusReason string `protobuf:"bytes,5,opt,name=status_reason,json=statusReason" json:"status_reason,omitempty"`
}

func (m *IntentStatus) Reset()                    { *m = IntentStatus{} }
func (m *IntentStatus) String() string            { return proto.CompactTextString(m) }
func (*IntentStatus) ProtoMessage()               {}
func (*IntentStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *IntentStatus) GetIntentId() string {
	if m != nil {
		return m.IntentId
	}
	return ""
}

func (m *IntentStatus) GetStatus() IntentStatus_Status {
	if m != nil {
		return m.Status
	}
	return IntentStatus_UNKNOWN
}

func (m *IntentStatus) GetTimestampUsec() uint64 {
	if m != nil {
		return m.TimestampUsec
	}
	return 0
}

func (m *IntentStatus) GetModifiedFlowFilter() *FlowFilter {
	if m != nil {
		return m.ModifiedFlowFilter
	}
	return nil
}

func (m *IntentStatus) GetStatusReason() string {
	if m != nil {
		return m.StatusReason
	}
	return ""
}

type NetworkPolicyStatus struct {
	IntentStatus []*IntentStatus `protobuf:"bytes,1,rep,name=intent_status,json=intentStatus" json:"intent_status,omitempty"`
}

func (m *NetworkPolicyStatus) Reset()                    { *m = NetworkPolicyStatus{} }
func (m *NetworkPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*NetworkPolicyStatus) ProtoMessage()               {}
func (*NetworkPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *NetworkPolicyStatus) GetIntentStatus() []*IntentStatus {
	if m != nil {
		return m.IntentStatus
	}
	return nil
}

// Status of policy enforcement as reported by one of the clients consuming
// TenantNetworkPolicy. Note that multiple clients can be consuming the same
// policy and enforcing at different point on the network. For example, a
// client for middle-boxes like load balancers might be enforcing a subset
// of the policies. These clients will report the status of what they are
// enforcing. Similarly a client for network orchestrator like ACI might
// enforce all the policies and report its enforcement status.
type TenantNetworkPolicyStatus struct {
	// Unique name assigned to tenant. It's the same as the root-scope name.
	TenantName string `protobuf:"bytes,1,opt,name=tenant_name,json=tenantName" json:"tenant_name,omitempty"`
	// Just like TenantNetworkPolicy we can have TenantNetworkPolicyStatus for
	// one tenant split across several TenantNetworkPolicyStatus messages. To
	// reconstruct the policy status we need to append NetworkPolicyStatus
	// from multiple messages.
	NetworkPolicyStatus []*NetworkPolicyStatus `protobuf:"bytes,2,rep,name=network_policy_status,json=networkPolicyStatus" json:"network_policy_status,omitempty"`
	RootScopeInfo       *RootScopeInfo         `protobuf:"bytes,3,opt,name=root_scope_info,json=rootScopeInfo" json:"root_scope_info,omitempty"`
	// Unique id assigned to the client that is reporting enforcement status.
	ClientId string `protobuf:"bytes,4,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
}

func (m *TenantNetworkPolicyStatus) Reset()                    { *m = TenantNetworkPolicyStatus{} }
func (m *TenantNetworkPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*TenantNetworkPolicyStatus) ProtoMessage()               {}
func (*TenantNetworkPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *TenantNetworkPolicyStatus) GetTenantName() string {
	if m != nil {
		return m.TenantName
	}
	return ""
}

func (m *TenantNetworkPolicyStatus) GetNetworkPolicyStatus() []*NetworkPolicyStatus {
	if m != nil {
		return m.NetworkPolicyStatus
	}
	return nil
}

func (m *TenantNetworkPolicyStatus) GetRootScopeInfo() *RootScopeInfo {
	if m != nil {
		return m.RootScopeInfo
	}
	return nil
}

func (m *TenantNetworkPolicyStatus) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

// The network policy updates we send over Kafka can be large; over a couple of
// GB each. Given that it is recommended to keep individual Kafka messages under
// 10MB we split each policy update into several smaller Kafka messages. To
// enable clients to correctly reconstruct the state and handle error scenarios
// we wrap each Kafka message under KafkaUpdate proto. Every policy update will
// have a begin marker UPDATE_START and end marker UPDATE_END.
// To reiterate every Policy update will have following set of messages:
//           - UPDATE_START indicates a new policy update begins.
//           - Several UPDATE messages with increasing sequence numbers.
//           - UPDATE_END indicates the new policy update is complete.
// Note that the first message (UPDATE_START) sequence number is zero and
// subsequent message's sequence numbers are strictly incremented by one.
// A client reading these updates should read all the messages from UPDATE_START
// to UPDATE_END. If any message is missing then client should skip all the
// messages until the next UPDATE_START message.
type KafkaUpdate struct {
	// Type of update message.
	Type KafkaUpdate_UpdateType `protobuf:"varint,1,opt,name=type,enum=TetrationNetworkPolicyProto.KafkaUpdate_UpdateType" json:"type,omitempty"`
	// Sequence number, starting with zero, is incremented by 1 for each
	// message that is part of a policy update.
	SequenceNum uint32 `protobuf:"varint,2,opt,name=sequence_num,json=sequenceNum" json:"sequence_num,omitempty"`
	// Partial details of the network policy. For Intents that are part of
	// different KafkaUpdate messages: the Intents in earlier message have higher
	// priority than intents in later messages. This message is populated on
	// Kafka where policy updates are pushed by Tetration.
	TenantNetworkPolicy *TenantNetworkPolicy `protobuf:"bytes,3,opt,name=tenant_network_policy,json=tenantNetworkPolicy" json:"tenant_network_policy,omitempty"`
	// Monotonically increasing version number of policy state.
	Version uint64 `protobuf:"varint,4,opt,name=version" json:"version,omitempty"`
	// This message is populated in Kafka topics that Tenants publish the
	// status of enforcement.
	NetworkPolicyStatus *TenantNetworkPolicyStatus `protobuf:"bytes,5,opt,name=network_policy_status,json=networkPolicyStatus" json:"network_policy_status,omitempty"`
}

func (m *KafkaUpdate) Reset()                    { *m = KafkaUpdate{} }
func (m *KafkaUpdate) String() string            { return proto.CompactTextString(m) }
func (*KafkaUpdate) ProtoMessage()               {}
func (*KafkaUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *KafkaUpdate) GetType() KafkaUpdate_UpdateType {
	if m != nil {
		return m.Type
	}
	return KafkaUpdate_UPDATE_START
}

func (m *KafkaUpdate) GetSequenceNum() uint32 {
	if m != nil {
		return m.SequenceNum
	}
	return 0
}

func (m *KafkaUpdate) GetTenantNetworkPolicy() *TenantNetworkPolicy {
	if m != nil {
		return m.TenantNetworkPolicy
	}
	return nil
}

func (m *KafkaUpdate) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *KafkaUpdate) GetNetworkPolicyStatus() *TenantNetworkPolicyStatus {
	if m != nil {
		return m.NetworkPolicyStatus
	}
	return nil
}

func init() {
	proto.RegisterType((*AddressWithPrefix)(nil), "TetrationNetworkPolicyProto.AddressWithPrefix")
	proto.RegisterType((*AddressWithRange)(nil), "TetrationNetworkPolicyProto.AddressWithRange")
	proto.RegisterType((*LBService)(nil), "TetrationNetworkPolicyProto.LBService")
	proto.RegisterType((*KeyValue)(nil), "TetrationNetworkPolicyProto.KeyValue")
	proto.RegisterType((*InventoryItem)(nil), "TetrationNetworkPolicyProto.InventoryItem")
	proto.RegisterType((*InventoryFilterMetaData)(nil), "TetrationNetworkPolicyProto.InventoryFilterMetaData")
	proto.RegisterType((*InventoryFilter)(nil), "TetrationNetworkPolicyProto.InventoryFilter")
	proto.RegisterType((*PortRange)(nil), "TetrationNetworkPolicyProto.PortRange")
	proto.RegisterType((*ProtocolAndPorts)(nil), "TetrationNetworkPolicyProto.ProtocolAndPorts")
	proto.RegisterType((*FlowFilter)(nil), "TetrationNetworkPolicyProto.FlowFilter")
	proto.RegisterType((*IntentMetaData)(nil), "TetrationNetworkPolicyProto.IntentMetaData")
	proto.RegisterType((*Intent)(nil), "TetrationNetworkPolicyProto.Intent")
	proto.RegisterType((*CatchAllPolicy)(nil), "TetrationNetworkPolicyProto.CatchAllPolicy")
	proto.RegisterType((*NetworkPolicy)(nil), "TetrationNetworkPolicyProto.NetworkPolicy")
	proto.RegisterType((*RootScopeInfo)(nil), "TetrationNetworkPolicyProto.RootScopeInfo")
	proto.RegisterType((*ScopeInfo)(nil), "TetrationNetworkPolicyProto.ScopeInfo")
	proto.RegisterType((*TenantNetworkPolicy)(nil), "TetrationNetworkPolicyProto.TenantNetworkPolicy")
	proto.RegisterType((*IntentStatus)(nil), "TetrationNetworkPolicyProto.IntentStatus")
	proto.RegisterType((*NetworkPolicyStatus)(nil), "TetrationNetworkPolicyProto.NetworkPolicyStatus")
	proto.RegisterType((*TenantNetworkPolicyStatus)(nil), "TetrationNetworkPolicyProto.TenantNetworkPolicyStatus")
	proto.RegisterType((*KafkaUpdate)(nil), "TetrationNetworkPolicyProto.KafkaUpdate")
	proto.RegisterEnum("TetrationNetworkPolicyProto.IPAddressFamily", IPAddressFamily_name, IPAddressFamily_value)
	proto.RegisterEnum("TetrationNetworkPolicyProto.IPProtocol", IPProtocol_name, IPProtocol_value)
	proto.RegisterEnum("TetrationNetworkPolicyProto.Intent_Action", Intent_Action_name, Intent_Action_value)
	proto.RegisterEnum("TetrationNetworkPolicyProto.Intent_TargetDevice", Intent_TargetDevice_name, Intent_TargetDevice_value)
	proto.RegisterEnum("TetrationNetworkPolicyProto.CatchAllPolicy_Action", CatchAllPolicy_Action_name, CatchAllPolicy_Action_value)
	proto.RegisterEnum("TetrationNetworkPolicyProto.IntentStatus_Status", IntentStatus_Status_name, IntentStatus_Status_value)
	proto.RegisterEnum("TetrationNetworkPolicyProto.KafkaUpdate_UpdateType", KafkaUpdate_UpdateType_name, KafkaUpdate_UpdateType_value)
}

func init() { proto.RegisterFile("proto/tetration_network_policy.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 3293 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x9a, 0x77, 0x78, 0x1b, 0xc9,
	0x75, 0xc0, 0x05, 0x90, 0x22, 0x89, 0x01, 0x41, 0x3d, 0xad, 0x74, 0x3e, 0x9e, 0x2f, 0xe7, 0xd3,
	0xe1, 0x7c, 0x67, 0x59, 0x56, 0x78, 0x04, 0x40, 0x82, 0xe4, 0xe5, 0x9c, 0x64, 0x01, 0x2c, 0x80,
	0x35, 0x81, 0xc5, 0x68, 0x76, 0x59, 0x14, 0x27, 0x41, 0xf6, 0x80, 0xa5, 0x04, 0x1f, 0xda, 0x61,
	0x97, 0x94, 0x99, 0xde, 0xed, 0x38, 0x3d, 0x4e, 0xaf, 0x76, 0x62, 0xa7, 0xe7, 0xd2, 0x9d, 0x38,
	0xbd, 0xf7, 0x5e, 0xed, 0xf4, 0xde, 0xbb, 0xe3, 0xf4, 0xf6, 0xbd, 0x37, 0x0b, 0x90, 0xc0, 0x28,
	0x10, 0x15, 0xe7, 0x2f, 0xcd, 0xfc, 0x66, 0xde, 0x9b, 0x37, 0xaf, 0xed, 0x40, 0x1f, 0xd9, 0x4b,
	0xfb, 0x83, 0x5e, 0xd0, 0x7b, 0x2a, 0xf0, 0x82, 0x81, 0x1b, 0xb4, 0x7a, 0xdd, 0x7a, 0xd7, 0x0b,
	0xee, 0xf4, 0x06, 0xcf, 0xd5, 0xfb, 0xbd, 0x76, 0xab, 0x71, 0xbc, 0x42, 0xcb, 0xda, 0xc3, 0xce,
	0x70, 0xdd, 0x92, 0xcb, 0x9c, 0x56, 0x39, 0x2e, 0x26, 0xdf, 0x14, 0x61, 0x17, 0xf5, 0x66, 0x73,
	0xe0, 0xf9, 0xfe, 0x5e, 0x2b, 0xb8, 0xcd, 0x07, 0xde, 0x41, 0xeb, 0xb5, 0xda, 0x83, 0x6c, 0xbe,
	0xd5, 0xaf, 0xbb, 0xcd, 0xe6, 0x60, 0x39, 0x72, 0x25, 0x72, 0x75, 0x51, 0xcc, 0xb5, 0xfa, 0xb8,
	0x4b, 0x7b, 0x9c, 0x25, 0xfa, 0xb4, 0xa5, 0xde, 0xf6, 0xba, 0xb7, 0x82, 0xdb, 0xcb, 0xd1, 0x2b,
	0x91, 0xab, 0x09, 0xb1, 0x28, 0x61, 0x85, 0x98, 0x56, 0x65, 0x71, 0x14, 0xad, 0x1f, 0xb8, 0x9d,
	0x56, 0xfb, 0x78, 0x79, 0xe6, 0x4a, 0xe4, 0xea, 0x52, 0xfa, 0xfa, 0xca, 0x14, 0x33, 0x56, 0x4c,
	0x1e, 0x1a, 0x51, 0x24, 0x19, 0xc1, 0x50, 0x81, 0x1c, 0x27, 0xdf, 0x1a, 0x61, 0x70, 0xca, 0x44,
	0xe1, 0x76, 0x6f, 0x79, 0x5a, 0x92, 0x25, 0xfc, 0xc0, 0x1d, 0x04, 0xf5, 0x71, 0x3b, 0xe3, 0x04,
	0x4d, 0x69, 0xec, 0x4b, 0x58, 0xdc, 0xeb, 0x36, 0x47, 0x3b, 0xa2, 0xb4, 0x23, 0xe6, 0x75, 0x9b,
	0xe1, 0xfa, 0xff, 0xb3, 0x9d, 0xaf, 0x8f, 0xb0, 0x58, 0x25, 0x67, 0x7b, 0x83, 0xa3, 0x56, 0xc3,
	0xd3, 0x72, 0x6c, 0xe6, 0xa8, 0xd5, 0x27, 0xb3, 0xe2, 0xe9, 0x95, 0xa9, 0x4a, 0x15, 0xff, 0x97,
	0xcf, 0x09, 0x14, 0xd6, 0x34, 0x36, 0x73, 0x38, 0x68, 0x93, 0xe1, 0x31, 0x64, 0x87, 0x83, 0xb6,
	0x76, 0x99, 0xcd, 0x76, 0xdd, 0x8e, 0x47, 0xd6, 0x22, 0xa4, 0x59, 0x2e, 0xc1, 0xe2, 0xe1, 0xc1,
	0x96, 0xdb, 0xf1, 0x92, 0x69, 0xb6, 0xb0, 0xed, 0x1d, 0xef, 0xba, 0xed, 0x43, 0x4f, 0x03, 0x36,
	0xf3, 0x9c, 0x77, 0x4c, 0x86, 0xc4, 0x04, 0x0e, 0xb5, 0xcb, 0xec, 0xfc, 0x11, 0x2e, 0x49, 0xc5,
	0x42, 0x4e, 0x92, 0x6f, 0x88, 0xb2, 0x84, 0xd9, 0x3d, 0xf2, 0xba, 0x41, 0x6f, 0x70, 0x6c, 0x06,
	0x5e, 0x47, 0xab, 0x31, 0x16, 0xfa, 0xce, 0xf3, 0xfd, 0xff, 0xf3, 0x4d, 0x62, 0x32, 0x75, 0x3c,
	0xdf, 0xd7, 0x1c, 0x96, 0x08, 0xb5, 0xd5, 0x07, 0x18, 0x45, 0x32, 0x20, 0x9e, 0x7e, 0xef, 0xb3,
	0xea, 0xa4, 0xd0, 0x97, 0xcf, 0x89, 0xc5, 0x50, 0x8b, 0x4c, 0x85, 0x12, 0x63, 0xed, 0x67, 0xeb,
	0xbe, 0xbc, 0xfe, 0xf2, 0x2c, 0xa9, 0x7c, 0x72, 0xaa, 0xca, 0x51, 0x94, 0xd0, 0xbc, 0xf6, 0xb3,
	0xe1, 0x24, 0x17, 0x63, 0xf3, 0xa1, 0xe2, 0xa4, 0xcd, 0x1e, 0x1c, 0xf9, 0xa2, 0xd8, 0x6a, 0x07,
	0xde, 0xa0, 0xea, 0x05, 0x6e, 0xc1, 0x0d, 0x5c, 0xed, 0x21, 0xb6, 0xe0, 0x37, 0x7a, 0x7d, 0xaf,
	0xde, 0x6a, 0x86, 0x4e, 0x9d, 0xa7, 0xb9, 0xd9, 0xd4, 0x1e, 0x61, 0x4c, 0x2e, 0x51, 0x84, 0xa4,
	0x77, 0x63, 0x44, 0x28, 0x2a, 0x2f, 0x44, 0xd9, 0x85, 0x09, 0xad, 0xda, 0x12, 0x8b, 0x8e, 0xf4,
	0x44, 0x5b, 0x4d, 0xcd, 0x66, 0x17, 0x5a, 0xc3, 0x2d, 0xf5, 0x56, 0xe0, 0x75, 0xfc, 0xe5, 0xe8,
	0x95, 0x99, 0xab, 0xf1, 0xf4, 0xb5, 0xe9, 0x79, 0x79, 0x3a, 0x70, 0x62, 0xa9, 0x75, 0x7a, 0xea,
	0x63, 0xc0, 0x9f, 0x3f, 0xf4, 0x06, 0x32, 0xc5, 0x63, 0x42, 0x4e, 0x34, 0x2d, 0xcc, 0xa4, 0x59,
	0x82, 0x34, 0xd6, 0xb6, 0xd8, 0x6c, 0xe0, 0xde, 0xf2, 0x97, 0xcf, 0xd3, 0x99, 0x4f, 0x4c, 0x3d,
	0x73, 0x98, 0x61, 0x82, 0x44, 0xb4, 0x1b, 0x2c, 0xd6, 0xf1, 0x02, 0xb7, 0xde, 0x74, 0x03, 0x77,
	0x79, 0x8e, 0xa2, 0xb0, 0x76, 0x36, 0x9b, 0xc7, 0x1d, 0x2c, 0x16, 0x3a, 0xe1, 0x28, 0x69, 0xb0,
	0x18, 0xef, 0x0d, 0x02, 0x19, 0x66, 0x74, 0x2e, 0x55, 0x7c, 0xbf, 0x37, 0x08, 0xc8, 0x63, 0x09,
	0x11, 0x23, 0x82, 0x7b, 0x30, 0x2c, 0x58, 0xec, 0xb4, 0x28, 0x9b, 0xd2, 0xbc, 0xd7, 0x6d, 0xe2,
	0x52, 0xf2, 0x6d, 0x11, 0x06, 0x74, 0x64, 0xa3, 0xd7, 0xd6, 0x25, 0xf3, 0xb5, 0x3c, 0x5b, 0xe8,
	0x87, 0x8c, 0x94, 0x2d, 0xa5, 0x5f, 0x76, 0x8f, 0xca, 0x1f, 0xaa, 0x10, 0x23, 0x41, 0xad, 0xc4,
	0xe2, 0x78, 0xa0, 0xcc, 0xe6, 0x61, 0xa4, 0xa6, 0xe7, 0xde, 0xe8, 0x42, 0x82, 0xf5, 0x87, 0x43,
	0x8a, 0x10, 0xce, 0xfc, 0xe5, 0x99, 0x2b, 0x33, 0x57, 0x13, 0x42, 0x4e, 0x92, 0xef, 0x8c, 0x30,
	0x56, 0x6c, 0xf7, 0xee, 0x84, 0xb9, 0xa2, 0x9d, 0xe4, 0x4a, 0x2e, 0xba, 0x1c, 0xa1, 0x7c, 0xb9,
	0xce, 0xb4, 0x46, 0xaf, 0xeb, 0x1f, 0x76, 0xbc, 0x41, 0xfd, 0x80, 0xb6, 0x61, 0x5e, 0xca, 0xd4,
	0x83, 0xe1, 0x8a, 0x94, 0x37, 0x69, 0x77, 0x7f, 0xd0, 0x3b, 0x6a, 0x35, 0xc7, 0x76, 0xcb, 0xac,
	0x80, 0xe1, 0xca, 0x68, 0xf7, 0xab, 0x69, 0x37, 0xdd, 0xb4, 0xee, 0x86, 0xbe, 0xf5, 0x97, 0x67,
	0xe9, 0x92, 0xd3, 0x6b, 0x76, 0xd2, 0xdb, 0xa4, 0x7c, 0x8c, 0x24, 0xdf, 0x11, 0x65, 0x4b, 0x66,
	0x37, 0xf0, 0xba, 0xc1, 0xa8, 0xb2, 0x1e, 0x66, 0xb1, 0x16, 0x91, 0x93, 0xd2, 0x5a, 0x90, 0xc0,
	0x6c, 0xe2, 0x27, 0xe9, 0xb6, 0xeb, 0xdf, 0x3e, 0xb9, 0xdd, 0x1c, 0x4e, 0xcd, 0xa6, 0xf6, 0x18,
	0x5b, 0xc4, 0xe3, 0xfd, 0xbe, 0xdb, 0xf0, 0x4e, 0x6e, 0x13, 0x1f, 0x31, 0xb3, 0xa9, 0x3d, 0xc1,
	0x2e, 0xb8, 0xcd, 0x0e, 0x65, 0x66, 0xdd, 0xf7, 0x48, 0xbd, 0x4c, 0xfa, 0x45, 0xb7, 0xd9, 0xc1,
	0xa3, 0x6d, 0x0f, 0x8f, 0x78, 0x8a, 0x5d, 0x1e, 0xdb, 0x76, 0xe4, 0x0d, 0xfc, 0x56, 0xaf, 0xbb,
	0x7c, 0x9e, 0xf6, 0x5e, 0x3c, 0xd9, 0xbb, 0x2b, 0x17, 0xb4, 0x0c, 0x7b, 0x91, 0xfc, 0xd2, 0xd6,
	0x43, 0xbb, 0x6f, 0x0d, 0x7a, 0x87, 0x7d, 0x54, 0x3f, 0x47, 0x22, 0x97, 0xe4, 0xaa, 0xbc, 0x66,
	0x09, 0xd7, 0xcc, 0xa6, 0xf6, 0x24, 0xbb, 0xd0, 0x68, 0x1f, 0xfa, 0xe8, 0x7b, 0xaf, 0x79, 0x8b,
	0x4c, 0x9e, 0xa7, 0xdd, 0x89, 0x10, 0x1b, 0xcd, 0x5b, 0x68, 0xf4, 0xe9, 0x3e, 0xb3, 0x30, 0xad,
	0xcf, 0xc4, 0x26, 0xfb, 0xcc, 0x5b, 0x66, 0xd9, 0x9c, 0x3c, 0x53, 0x69, 0x2f, 0x65, 0x16, 0x3f,
	0x68, 0xf7, 0xee, 0x84, 0xc1, 0x0f, 0xfb, 0xef, 0xf4, 0xc4, 0x3f, 0x49, 0x40, 0xc1, 0x0e, 0x4e,
	0x92, 0x31, 0xc7, 0xe6, 0xdc, 0x06, 0x8a, 0x84, 0xdf, 0xcd, 0x7b, 0xf5, 0x27, 0x34, 0x67, 0x45,
	0x27, 0x09, 0x11, 0x4a, 0x6a, 0x7b, 0x6c, 0x29, 0x70, 0x07, 0xb7, 0xbc, 0xa0, 0xde, 0xf4, 0xb0,
	0x03, 0xcb, 0xe4, 0x5a, 0x4a, 0xaf, 0x9e, 0x45, 0x97, 0x43, 0x92, 0x05, 0x12, 0x14, 0x89, 0xe0,
	0xd4, 0xcc, 0x7f, 0x4f, 0xda, 0x58, 0x59, 0x6d, 0x63, 0xaf, 0x38, 0x83, 0x39, 0x6a, 0xf7, 0xd2,
	0x1e, 0x65, 0xf1, 0x30, 0x2d, 0x28, 0x4c, 0x32, 0xc8, 0x4c, 0x22, 0x8a, 0xd3, 0x35, 0x36, 0x27,
	0x1d, 0xa2, 0xc5, 0xd9, 0xbc, 0x69, 0xed, 0xea, 0x15, 0xb3, 0x00, 0xe7, 0xb4, 0x18, 0x3b, 0xaf,
	0x57, 0x2a, 0xb5, 0x3d, 0x88, 0x68, 0x0b, 0x6c, 0xb6, 0x20, 0x6a, 0x1c, 0xa2, 0xc9, 0x1b, 0x6c,
	0xf1, 0xf4, 0x85, 0xb5, 0x45, 0xb6, 0xb0, 0x57, 0x13, 0xdb, 0x95, 0x9a, 0x8e, 0x22, 0x1a, 0x5b,
	0xb2, 0x0c, 0x07, 0x41, 0xbd, 0xa8, 0xe7, 0x84, 0x99, 0x87, 0x88, 0x06, 0x6c, 0xb1, 0x6a, 0x16,
	0x0a, 0x15, 0xa3, 0x9e, 0xab, 0xed, 0x1b, 0x36, 0x44, 0xb5, 0x04, 0x8b, 0x15, 0x4d, 0x61, 0xec,
	0xe9, 0x95, 0x8a, 0x0d, 0x33, 0xf8, 0x5e, 0x59, 0xca, 0xbb, 0x41, 0xe3, 0xb6, 0xde, 0x6e, 0xcb,
	0x0b, 0x69, 0xaf, 0x1a, 0x05, 0x55, 0xb6, 0xc4, 0xf4, 0xd4, 0x9b, 0x8f, 0x0b, 0x4f, 0x04, 0xf7,
	0xbe, 0x6e, 0xf7, 0xae, 0x08, 0x4b, 0x8c, 0x1d, 0xa0, 0xdd, 0x64, 0x17, 0x4f, 0xbe, 0x83, 0x32,
	0x5b, 0xf1, 0x09, 0x82, 0xe1, 0xbc, 0x7e, 0x3f, 0x5f, 0x15, 0x01, 0xad, 0x71, 0xe0, 0x6b, 0xaf,
	0x64, 0xf3, 0x32, 0x08, 0xc3, 0x86, 0xfd, 0xf8, 0x19, 0xe2, 0x2b, 0x86, 0x32, 0x98, 0x20, 0x0d,
	0xbc, 0x78, 0xdd, 0x6d, 0xb7, 0x29, 0xf7, 0xef, 0x95, 0x20, 0xe3, 0x6e, 0x12, 0x0b, 0x8d, 0x70,
	0x9e, 0xcc, 0xb0, 0x84, 0xe8, 0xf5, 0x02, 0x9b, 0xaa, 0xba, 0x7b, 0xd0, 0x53, 0xaa, 0x75, 0xf8,
	0x85, 0x8e, 0x9e, 0x7c, 0xa1, 0x93, 0xaf, 0x8b, 0xb0, 0xd8, 0x7d, 0x49, 0x60, 0x5b, 0xed, 0xbb,
	0x83, 0xb0, 0xad, 0xca, 0xee, 0xb8, 0x20, 0x81, 0xd9, 0x1c, 0x55, 0xca, 0xec, 0x7d, 0x57, 0x4a,
	0xf2, 0xed, 0x33, 0xec, 0x92, 0xe3, 0x75, 0xdd, 0x6e, 0x30, 0x1e, 0xba, 0x47, 0x59, 0x3c, 0x20,
	0x2c, 0xf3, 0x5e, 0x1a, 0xc7, 0x24, 0xc2, 0xbc, 0xd7, 0x6e, 0xb0, 0xa5, 0xf1, 0x1f, 0x2a, 0x67,
	0x7a, 0xe2, 0x8c, 0x21, 0x91, 0xe8, 0x8e, 0x9d, 0xf9, 0x18, 0x5b, 0x1c, 0xaa, 0x3c, 0x1a, 0x1c,
	0xc8, 0xcf, 0x68, 0x4c, 0xc4, 0x43, 0xb6, 0x3b, 0x38, 0xf0, 0x35, 0xc1, 0x2e, 0x0c, 0x7a, 0xbd,
	0xa0, 0x1e, 0x36, 0xd5, 0xee, 0x41, 0x2f, 0x7c, 0x2b, 0x4e, 0x3f, 0x76, 0x2c, 0x42, 0x22, 0x31,
	0x18, 0x0b, 0x98, 0xc3, 0xe6, 0x48, 0xdd, 0xb0, 0xd3, 0x3c, 0x33, 0x55, 0xd5, 0x5d, 0x9c, 0xb5,
	0x42, 0xba, 0x7c, 0xa3, 0x1b, 0x0c, 0x8e, 0x45, 0xa8, 0xeb, 0xc5, 0x2e, 0x8b, 0x9f, 0xc2, 0x77,
	0x79, 0xc0, 0x3f, 0x73, 0xfa, 0x01, 0x7f, 0xaf, 0x07, 0xc7, 0x89, 0xf1, 0x52, 0xe8, 0xe9, 0xe8,
	0x66, 0x24, 0xf9, 0xee, 0x28, 0x5b, 0x94, 0x89, 0x6d, 0x07, 0x6e, 0x70, 0xe8, 0x4f, 0xff, 0xf6,
	0x96, 0xd9, 0x9c, 0x4f, 0xdb, 0xe8, 0xc0, 0xb3, 0xf5, 0x67, 0xa9, 0x77, 0x45, 0xfe, 0x23, 0x42,
	0x79, 0xed, 0x09, 0xb6, 0x14, 0xb4, 0x3a, 0x9e, 0x1f, 0xb8, 0x9d, 0x7e, 0xfd, 0xd0, 0xf7, 0x1a,
	0x94, 0x90, 0xb3, 0x22, 0x31, 0xa2, 0x3b, 0xbe, 0xd7, 0xd0, 0x6e, 0xb2, 0xcb, 0x9d, 0x5e, 0xb3,
	0x75, 0xd0, 0xf2, 0x9a, 0xf5, 0xd3, 0xdf, 0xab, 0xd9, 0xfb, 0xfb, 0x5e, 0x69, 0x43, 0x25, 0xa7,
	0x1e, 0x51, 0x8f, 0xd3, 0x0f, 0xc7, 0xe0, 0xd0, 0xaf, 0x0f, 0x3c, 0xd7, 0x1f, 0x7d, 0xdd, 0x17,
	0x25, 0x14, 0xc4, 0x92, 0x7b, 0x6c, 0x2e, 0xf4, 0x4b, 0x9c, 0xcd, 0xef, 0x58, 0xdb, 0x56, 0x6d,
	0xcf, 0x82, 0x73, 0xd4, 0xc8, 0x4a, 0x56, 0x4d, 0x18, 0x05, 0x88, 0x68, 0x8c, 0xcd, 0x15, 0x75,
	0xb3, 0x62, 0x14, 0x20, 0x8a, 0xdd, 0xd8, 0xb0, 0x8a, 0x35, 0x91, 0x37, 0x0a, 0x30, 0xa3, 0x3d,
	0xc4, 0x1e, 0xa8, 0xd6, 0x0a, 0x66, 0xd1, 0x34, 0x0a, 0x75, 0xdd, 0x2a, 0xd4, 0x47, 0x4b, 0xb3,
	0x49, 0x8f, 0x5d, 0x1a, 0x33, 0x39, 0x3c, 0xc5, 0x62, 0x89, 0xd0, 0xfb, 0xa1, 0x9f, 0x65, 0xa7,
	0x7b, 0xf9, 0x99, 0xfd, 0x2c, 0x16, 0x5b, 0xa7, 0x66, 0xc9, 0x37, 0x46, 0xd9, 0x43, 0x77, 0xc9,
	0xb6, 0xf0, 0xb4, 0x7b, 0x16, 0x68, 0x93, 0x3d, 0x30, 0x5e, 0xa0, 0xf5, 0x51, 0xf8, 0xd1, 0xac,
	0xd5, 0xb3, 0xd7, 0x69, 0x68, 0xdd, 0xa5, 0xee, 0x5d, 0xcc, 0xb8, 0x4b, 0x41, 0xce, 0xbc, 0xa7,
	0x05, 0xf9, 0x30, 0x8b, 0x35, 0xda, 0xad, 0x30, 0x8d, 0xe5, 0x1b, 0x6f, 0x41, 0x02, 0xb3, 0x99,
	0x7c, 0xf3, 0x0c, 0x8b, 0x6f, 0xbb, 0x07, 0xcf, 0xb9, 0x3b, 0xfd, 0xa6, 0x1b, 0xe0, 0x0f, 0xc7,
	0xd9, 0xe0, 0xb8, 0xef, 0x85, 0xdf, 0xba, 0xcc, 0xf4, 0xde, 0x77, 0x22, 0xb7, 0x22, 0xff, 0x71,
	0x8e, 0xfb, 0xd8, 0x09, 0x8f, 0xfb, 0x1e, 0x76, 0x1f, 0xdf, 0x7b, 0xfe, 0xd0, 0xeb, 0x36, 0xbc,
	0x7a, 0xf7, 0xb0, 0x13, 0xfe, 0xfe, 0x88, 0x0f, 0x99, 0x75, 0xd8, 0x41, 0x97, 0x0e, 0x7d, 0x3e,
	0xde, 0xfa, 0xe4, 0x95, 0x57, 0xef, 0xb7, 0x71, 0x88, 0x4b, 0xc1, 0x5d, 0x5a, 0xef, 0x32, 0x9b,
	0x1f, 0x3e, 0x5a, 0x67, 0xa9, 0xae, 0x86, 0x53, 0xed, 0x35, 0xff, 0x5b, 0x48, 0xcf, 0xd3, 0xf9,
	0xd9, 0xfb, 0x3d, 0x7f, 0x4a, 0x60, 0x93, 0x4f, 0x33, 0x76, 0xe2, 0x22, 0x7c, 0x87, 0xec, 0xf0,
	0x82, 0xee, 0x18, 0x75, 0xdb, 0xd1, 0x85, 0x03, 0xe7, 0xb0, 0x72, 0x24, 0x81, 0x88, 0xb6, 0xc4,
	0x58, 0xb8, 0x6a, 0x58, 0x05, 0x88, 0x5e, 0x4b, 0xb3, 0x0b, 0x13, 0xff, 0xc7, 0x32, 0xfe, 0x7c,
	0x58, 0x60, 0xb3, 0x26, 0x3f, 0x5a, 0x93, 0xaf, 0x07, 0x93, 0x1f, 0x65, 0x21, 0x7a, 0xed, 0x85,
	0x47, 0x18, 0x3b, 0xf9, 0x79, 0xa6, 0xcd, 0xb1, 0xa8, 0xc9, 0xc3, 0xad, 0xf9, 0x2a, 0x0f, 0xb7,
	0x96, 0xaa, 0x1c, 0xa2, 0xda, 0x3c, 0x9b, 0x29, 0x95, 0x38, 0xcc, 0x48, 0x69, 0x93, 0xc3, 0x2c,
	0x6e, 0xb7, 0x1d, 0x38, 0x8f, 0x4b, 0x4e, 0x9e, 0xc3, 0x1c, 0x0e, 0xf2, 0x39, 0x07, 0xe6, 0x71,
	0x60, 0x94, 0x38, 0x2c, 0xe0, 0xc0, 0x2c, 0x71, 0x88, 0xa1, 0xe5, 0xb9, 0x9c, 0x25, 0xf2, 0x79,
	0x60, 0x08, 0xad, 0x5d, 0x0e, 0x71, 0x1c, 0xf0, 0x1d, 0x0e, 0x8b, 0xf4, 0xb4, 0x11, 0xa5, 0x1d,
	0x1b, 0x12, 0x38, 0x34, 0xaa, 0xf9, 0x9a, 0x05, 0x4b, 0x78, 0xd2, 0xbe, 0x65, 0x38, 0x70, 0x01,
	0x61, 0xbe, 0xac, 0xd7, 0x6c, 0x00, 0x94, 0xd9, 0x29, 0x70, 0xb8, 0x88, 0x83, 0xea, 0xce, 0x3e,
	0x68, 0x78, 0xcb, 0x42, 0xde, 0xaa, 0x1a, 0xba, 0x0d, 0x97, 0x90, 0x96, 0xab, 0x1c, 0x2e, 0x93,
	0x6e, 0x51, 0x85, 0x07, 0xc8, 0x84, 0x02, 0x87, 0x17, 0xa1, 0x09, 0x8e, 0xd8, 0xb1, 0xb6, 0x53,
	0xf0, 0xe0, 0x68, 0x9c, 0x86, 0x65, 0x54, 0x5e, 0x31, 0xf4, 0x62, 0x0a, 0x1e, 0x1a, 0x0e, 0xd3,
	0xf0, 0x62, 0x14, 0x13, 0x05, 0x0e, 0x0f, 0xd3, 0x7d, 0x85, 0xc3, 0xe1, 0xbd, 0xf0, 0xbe, 0x0e,
	0x87, 0x47, 0x50, 0xd8, 0x32, 0x9c, 0x5c, 0xc5, 0x81, 0x97, 0xe0, 0xb8, 0x5a, 0xe4, 0x96, 0xcd,
	0xe1, 0x51, 0xec, 0x65, 0x55, 0x43, 0x98, 0x8e, 0x69, 0x71, 0xb8, 0x82, 0x0a, 0x6c, 0x83, 0xc3,
	0x63, 0xa8, 0xa0, 0x9e, 0xe1, 0x79, 0x48, 0x92, 0xaa, 0x02, 0x17, 0xf0, 0x38, 0x2e, 0xee, 0x3b,
	0x1c, 0x5e, 0x8a, 0x83, 0x42, 0x81, 0xc3, 0x13, 0xb8, 0x96, 0xaf, 0x3a, 0x1c, 0x9e, 0xc4, 0x91,
	0xc3, 0x39, 0x87, 0x97, 0x51, 0x3c, 0x2a, 0x70, 0x95, 0xae, 0xc0, 0xb3, 0xf0, 0x72, 0x5c, 0xb2,
	0x0b, 0x82, 0xc3, 0x35, 0xbc, 0xb4, 0xa8, 0xed, 0x38, 0xa6, 0x55, 0x82, 0x57, 0xe0, 0xc1, 0x45,
	0xa1, 0x97, 0xaa, 0x86, 0xe5, 0xc0, 0x75, 0xdc, 0x24, 0xec, 0x5d, 0x0e, 0x2b, 0x14, 0x33, 0x61,
	0xc0, 0x53, 0x88, 0xaa, 0x65, 0xc1, 0x61, 0x95, 0x22, 0x63, 0xe9, 0x90, 0xa2, 0x81, 0xcd, 0x21,
	0x8d, 0x87, 0xe8, 0x65, 0xc8, 0xe0, 0xdd, 0x4d, 0xab, 0x62, 0x73, 0x58, 0xc3, 0xa1, 0xbd, 0x67,
	0x72, 0x03, 0xd6, 0x51, 0xd2, 0xd2, 0x05, 0x87, 0x2c, 0xdd, 0xb4, 0x96, 0x33, 0x2b, 0x06, 0x6c,
	0x90, 0x89, 0xb8, 0x75, 0x93, 0x2c, 0xda, 0x36, 0x39, 0x6c, 0x91, 0x7c, 0xbe, 0xca, 0xb3, 0xf0,
	0x34, 0x09, 0xd5, 0x2c, 0x03, 0xde, 0x87, 0x62, 0x63, 0x3b, 0x35, 0xee, 0xd8, 0xf0, 0x0c, 0x4e,
	0x74, 0xeb, 0x66, 0xb9, 0x66, 0x3b, 0xf0, 0x4a, 0xba, 0x6f, 0xd1, 0xe1, 0xf0, 0xbe, 0xa8, 0x58,
	0xb7, 0x6e, 0x62, 0xa0, 0xdf, 0x8f, 0xa2, 0xbf, 0xcf, 0xf5, 0x6d, 0x78, 0x7f, 0x7c, 0x73, 0x6f,
	0x8b, 0x9b, 0xdc, 0xa9, 0x55, 0x74, 0x0b, 0x74, 0x8a, 0xc7, 0x6e, 0x01, 0x72, 0x32, 0xff, 0x78,
	0x1e, 0xf2, 0x28, 0x58, 0x30, 0x6d, 0xa7, 0x68, 0x43, 0x01, 0xc7, 0xb6, 0xee, 0x54, 0x6b, 0x16,
	0x18, 0xb8, 0x63, 0xd7, 0xb4, 0x75, 0x28, 0xca, 0xbd, 0xf9, 0x5d, 0x28, 0xd1, 0x71, 0xdc, 0xda,
	0x87, 0xb2, 0x1c, 0x95, 0x73, 0x60, 0xa2, 0xca, 0x3d, 0xdb, 0x82, 0x57, 0x51, 0xae, 0xec, 0x72,
	0xd8, 0x46, 0x47, 0xe6, 0x44, 0xa8, 0xa7, 0x42, 0x6e, 0xd8, 0xb1, 0xac, 0x02, 0x54, 0x71, 0xb8,
	0x97, 0x43, 0x6a, 0xe1, 0x2d, 0xf6, 0x72, 0xd2, 0xc8, 0x1a, 0x79, 0xb1, 0x66, 0x01, 0xa7, 0x33,
	0x31, 0x7c, 0x37, 0x48, 0x8a, 0x86, 0x02, 0x87, 0xbb, 0xa6, 0x65, 0xd8, 0x60, 0x53, 0x8d, 0x38,
	0x1c, 0x1c, 0x4a, 0x1e, 0xbb, 0x88, 0x45, 0xb1, 0x43, 0xc1, 0x2f, 0x71, 0xd8, 0x95, 0x15, 0x54,
	0x84, 0x3d, 0xba, 0xbf, 0x59, 0x12, 0x1c, 0xf6, 0x51, 0x63, 0xcd, 0xe6, 0x45, 0xb8, 0x89, 0x9e,
	0xb0, 0xb9, 0x30, 0x1d, 0x43, 0xf0, 0x3c, 0x7c, 0x00, 0x2e, 0x54, 0x30, 0x24, 0xaf, 0xa6, 0x12,
	0x70, 0x38, 0x7c, 0x20, 0x22, 0x7d, 0x3f, 0xbd, 0x0e, 0x1f, 0x84, 0x7b, 0xb1, 0x3a, 0x0d, 0x2b,
	0xaf, 0x73, 0xf8, 0x60, 0x0a, 0xbc, 0x99, 0xe7, 0x50, 0x27, 0xb3, 0xf2, 0x79, 0x9b, 0xc3, 0x87,
	0xe0, 0x0d, 0x0c, 0xa7, 0x6c, 0x08, 0x93, 0x83, 0x4b, 0x27, 0xd2, 0xe6, 0x67, 0xc3, 0x40, 0x18,
	0x56, 0x1e, 0x1a, 0x28, 0x58, 0x42, 0xdd, 0x4d, 0xf2, 0x61, 0xb1, 0xca, 0xc1, 0xc3, 0x11, 0xb7,
	0x2c, 0x13, 0x0e, 0xc8, 0x61, 0x66, 0x15, 0x6e, 0xd1, 0xc1, 0xc2, 0xb4, 0xe1, 0x36, 0x25, 0x42,
	0x9e, 0xdb, 0xd0, 0xc2, 0xc5, 0x1b, 0xd6, 0x3e, 0xbc, 0x86, 0x32, 0xcb, 0x82, 0xe7, 0x50, 0xaf,
	0xc9, 0xf3, 0xb5, 0x2a, 0x87, 0x36, 0x55, 0x85, 0xc5, 0xa1, 0x83, 0xed, 0x0b, 0x91, 0x7e, 0x83,
	0x1b, 0x86, 0x80, 0x2e, 0xa5, 0x0f, 0xdf, 0x37, 0x39, 0xf4, 0xc8, 0x97, 0x42, 0x70, 0xe8, 0xd3,
	0x39, 0xa5, 0x2a, 0x3c, 0x1f, 0xa6, 0xce, 0x6a, 0xb9, 0xc6, 0x61, 0x40, 0x0e, 0x48, 0x3b, 0x1c,
	0x7c, 0x59, 0x3d, 0xfb, 0x10, 0x90, 0x91, 0xba, 0xc3, 0xe1, 0x90, 0x0e, 0x70, 0x38, 0x1c, 0xd1,
	0x40, 0x70, 0xb8, 0x43, 0x1d, 0xc3, 0x31, 0xe1, 0xb5, 0x44, 0xaa, 0x1c, 0x8e, 0xa9, 0x71, 0x55,
	0xe1, 0x43, 0x49, 0xbd, 0xc3, 0xe1, 0xc3, 0x48, 0xdc, 0x36, 0x6d, 0xf8, 0x70, 0x1c, 0xe1, 0x2f,
	0x3d, 0xf8, 0x08, 0xca, 0x13, 0xac, 0xfb, 0x8f, 0xa4, 0xee, 0x23, 0xb0, 0xe9, 0x7c, 0x94, 0x96,
	0x60, 0x0b, 0xb6, 0x9d, 0xaf, 0xf1, 0x6a, 0xde, 0x80, 0x8f, 0x8e, 0x68, 0x31, 0xcc, 0xaf, 0x8a,
	0x03, 0x1f, 0x83, 0x9d, 0x72, 0xc6, 0xe6, 0x36, 0x7c, 0x2c, 0x41, 0x8c, 0x00, 0x7c, 0x1c, 0x0d,
	0xed, 0xbc, 0xc3, 0xe1, 0xe3, 0x23, 0xda, 0x3c, 0x8b, 0x16, 0xf3, 0xf0, 0x09, 0x11, 0x6d, 0x91,
	0xcd, 0x63, 0x79, 0x9a, 0x25, 0x0b, 0x3e, 0x31, 0xa2, 0x5d, 0x62, 0x4b, 0x54, 0x55, 0xa6, 0x73,
	0xb3, 0x6c, 0xe8, 0x05, 0x43, 0xc0, 0xeb, 0x68, 0xcb, 0x4e, 0x81, 0x57, 0x4c, 0xc7, 0x80, 0xd7,
	0x47, 0xf0, 0xcc, 0x2a, 0xaf, 0xd8, 0xa6, 0x65, 0x72, 0xf8, 0x24, 0x7c, 0x3d, 0x9d, 0xaf, 0xea,
	0x58, 0x2d, 0x6f, 0xa0, 0x43, 0xcb, 0x26, 0x87, 0x4f, 0x26, 0x6a, 0x97, 0xcd, 0x6a, 0x16, 0x3e,
	0x85, 0x4e, 0xdd, 0xc3, 0xda, 0xfe, 0x54, 0x1a, 0x8a, 0x5a, 0x39, 0x0f, 0x9f, 0x16, 0xd1, 0x34,
	0x96, 0xd8, 0xb1, 0x74, 0xdb, 0x36, 0x4b, 0x96, 0x51, 0x48, 0xad, 0x65, 0xe0, 0xd3, 0x15, 0xb6,
	0x06, 0x9f, 0xa1, 0xb0, 0x75, 0xf8, 0x4c, 0x85, 0x65, 0xe1, 0xb3, 0x14, 0xb6, 0x01, 0x6f, 0x54,
	0xd8, 0x26, 0x7c, 0xb6, 0xc2, 0xb6, 0xe0, 0x73, 0x26, 0xd9, 0xfa, 0x2a, 0x7c, 0xae, 0xc2, 0x52,
	0xf0, 0x79, 0x0a, 0x4b, 0xc3, 0xe7, 0x2b, 0x2c, 0x03, 0x5f, 0xa0, 0xb0, 0x35, 0xf8, 0x42, 0x85,
	0xad, 0xc3, 0x17, 0x29, 0x2c, 0x0b, 0x5f, 0xac, 0xb0, 0x0d, 0xf8, 0x12, 0x85, 0x6d, 0xc2, 0x97,
	0x2a, 0x6c, 0x0b, 0xbe, 0x6c, 0x92, 0x65, 0x57, 0xe1, 0x4d, 0x0a, 0x4b, 0xc1, 0x9b, 0x15, 0x96,
	0x86, 0x2f, 0x57, 0x58, 0x06, 0xbe, 0x42, 0x61, 0x6b, 0xf0, 0x16, 0x85, 0xad, 0xc3, 0x5b, 0x15,
	0x96, 0x85, 0xaf, 0x54, 0xd8, 0x06, 0x7c, 0x95, 0xc2, 0x36, 0xe1, 0xab, 0x15, 0xb6, 0x05, 0x5f,
	0x33, 0xc9, 0x36, 0x56, 0xe1, 0x6b, 0x15, 0x96, 0x82, 0xaf, 0x53, 0x58, 0x1a, 0xbe, 0x5e, 0x61,
	0x19, 0xf8, 0x06, 0x85, 0xad, 0xc1, 0x0b, 0x0a, 0x5b, 0x87, 0x6f, 0x54, 0x58, 0x16, 0xbe, 0x49,
	0x61, 0x1b, 0xf0, 0xcd, 0x0a, 0xdb, 0x84, 0x6f, 0x51, 0xd8, 0x16, 0x7c, 0xeb, 0x24, 0xdb, 0x5c,
	0x85, 0x6f, 0x53, 0x58, 0x0a, 0xbe, 0x5d, 0x61, 0x69, 0x78, 0x9b, 0xc2, 0x32, 0xf0, 0x1d, 0x0a,
	0x5b, 0x83, 0xef, 0x54, 0xd8, 0x3a, 0xbc, 0x5d, 0x61, 0x59, 0xf8, 0x2e, 0x85, 0x6d, 0xc0, 0x77,
	0x2b, 0x6c, 0x13, 0xbe, 0x47, 0x61, 0x5b, 0xf0, 0xbd, 0x93, 0x6c, 0x6b, 0x15, 0xbe, 0x4f, 0x61,
	0x29, 0xf8, 0x7e, 0x85, 0xa5, 0xe1, 0x07, 0x14, 0x96, 0x81, 0x1f, 0x54, 0xd8, 0x1a, 0xfc, 0x90,
	0xc2, 0xd6, 0xe1, 0x87, 0x15, 0x96, 0x85, 0x1f, 0x51, 0xd8, 0x06, 0xfc, 0xa8, 0xc2, 0x36, 0xe1,
	0xc7, 0x14, 0xb6, 0x05, 0x3f, 0x3e, 0xc1, 0xd2, 0xab, 0xab, 0xf0, 0x13, 0x0a, 0x4b, 0xc1, 0x4f,
	0x2a, 0x2c, 0x0d, 0x3f, 0xa5, 0xb0, 0x0c, 0xfc, 0xb4, 0xc2, 0xd6, 0xe0, 0x67, 0x14, 0xb6, 0x0e,
	0x3f, 0xab, 0xb0, 0x2c, 0xfc, 0x9c, 0xc2, 0x36, 0xe0, 0xe7, 0x15, 0xb6, 0x09, 0xbf, 0xa0, 0xb0,
	0x2d, 0xf8, 0xc5, 0x49, 0x96, 0x5a, 0x85, 0x5f, 0x52, 0x58, 0x0a, 0x7e, 0x59, 0x61, 0x69, 0xf8,
	0x15, 0x85, 0x65, 0xe0, 0x57, 0x15, 0xb6, 0x06, 0xbf, 0xa6, 0xb0, 0x75, 0xf8, 0x75, 0x85, 0x65,
	0xe1, 0x1d, 0x0a, 0xdb, 0x80, 0x77, 0x2a, 0x6c, 0x13, 0x7e, 0x43, 0x61, 0x5b, 0xf0, 0x9b, 0x93,
	0x2c, 0xbd, 0x0a, 0xbf, 0xa5, 0xb0, 0x14, 0xfc, 0xb6, 0xc2, 0xd2, 0xf0, 0x3b, 0x0a, 0xcb, 0xc0,
	0xef, 0x2a, 0x6c, 0x0d, 0x7e, 0x4f, 0x61, 0xeb, 0xf0, 0xfb, 0x0a, 0xcb, 0xc2, 0x1f, 0x28, 0x6c,
	0x03, 0xfe, 0x50, 0x61, 0x9b, 0xf0, 0x47, 0x0a, 0xdb, 0x82, 0x3f, 0x9e, 0x64, 0x99, 0x55, 0xf8,
	0x13, 0x85, 0xa5, 0xe0, 0x4f, 0x15, 0x96, 0x86, 0x3f, 0x53, 0x58, 0x06, 0xfe, 0x5c, 0x61, 0x6b,
	0xf0, 0x17, 0x0a, 0x5b, 0x87, 0xbf, 0x54, 0x58, 0x16, 0xfe, 0x4a, 0x61, 0x1b, 0xf0, 0xd7, 0x0a,
	0xdb, 0x84, 0xbf, 0x51, 0xd8, 0x16, 0xfc, 0xed, 0x24, 0x5b, 0x5b, 0x85, 0xbf, 0x53, 0x58, 0x0a,
	0xfe, 0x5e, 0x61, 0x69, 0xf8, 0x07, 0x85, 0x65, 0xe0, 0x5d, 0x0a, 0x5b, 0x83, 0x7f, 0x54, 0xd8,
	0x3a, 0xbc, 0x5b, 0x61, 0x59, 0xf8, 0x27, 0x7a, 0x89, 0xe8, 0x82, 0xd7, 0x85, 0xb1, 0x2b, 0x8c,
	0x1b, 0x3b, 0x86, 0xed, 0xc0, 0x3f, 0x47, 0xb4, 0x8b, 0x6c, 0x71, 0x04, 0x79, 0xe5, 0x26, 0xfc,
	0x4b, 0x44, 0x03, 0x16, 0x97, 0x48, 0x6e, 0xfa, 0x57, 0xfc, 0x25, 0x1a, 0x93, 0x04, 0x77, 0xfc,
	0xdb, 0xa4, 0xf6, 0xf5, 0x14, 0xfc, 0xbb, 0xc2, 0xd2, 0xf0, 0x1f, 0xa4, 0xc9, 0xd8, 0xe7, 0x86,
	0x30, 0xf1, 0x87, 0x4b, 0x0a, 0xfe, 0x73, 0x82, 0xa4, 0xe1, 0xbf, 0xe8, 0xf1, 0x23, 0x0c, 0xdb,
	0x10, 0xbb, 0x46, 0x01, 0xfe, 0x3b, 0x92, 0xdb, 0x66, 0xd7, 0x1b, 0xbd, 0xce, 0xca, 0xe8, 0xef,
	0x36, 0x56, 0xa6, 0xff, 0x05, 0x47, 0x6e, 0xda, 0x5f, 0x70, 0x3c, 0x3b, 0x47, 0x7b, 0x32, 0xff,
	0x13, 0x00, 0x00, 0xff, 0xff, 0xcd, 0x58, 0x7c, 0x9c, 0x0d, 0x22, 0x00, 0x00,
}
